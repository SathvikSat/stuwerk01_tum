import "RISCVBase.core_desc"

InstructionSet RV32Zpn extends RV32I {
    architectural_state {
        unsigned<32> VXSAT_ADDR__ = 0x009;
        unsigned<32>& VXSAT_CSR__ = CSR[VXSAT_ADDR__];
    }
instructions {
//--------------
// ||CLZ||
//--------------
//Instruction description:-
// Starting from the most significant bits of the Rs1 register, this instruction counts the number of leading zero bits and writes the results to Rd. If the content of Rs1 is 0, the result is 32. If the content of Rs1 is -1, the result is 0.
//
//Instruction operation:-
//
//
// cnt = 0;
// for (i = 31 to 0) {
//   if (Rs1[i] == 0) {
//     cnt = cnt + 1;
//   } else {
//     break;
//   }
// }
// Rd = cnt;
//
//Instruction syntax:-   CLZ Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0|0110000 |CLZ +00000 |Rs1 |001 |Rd|OP-IMM +0010011
    CLZ {
        encoding: 0b001 :: rs1[4:0] :: 0b :: rd[4:0] :: 0b;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CMIX||
//--------------
//Instruction description:-
// This instruction selects individual bits from Rs1 or Rs3, based on
//the bit mask value in Rs2. If a bit in Rs2 is 1, the corresponding bit is from Rs1;
//otherwise, the corresponding bit is from Rs3. The selection results are written to Rd.
//
//Instruction operation:-
//
//
// Rd[x] = Rs2[x]? Rs1[x] : Rs3[x];
// for RV32, x=31..0
// for RV64, x=63..0
//
//Instruction syntax:-   CMIX  Rd, Rs2, Rs1, Rs3
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    27 l|26  25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|Rs3 |CMIX +
//11 |Rs2 |Rs1 |CMIX +
//001 |Rd
//|OP +
//0110011
//
    CMIX {
        encoding: 0b11:: rs3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b0110011;
        args_disass:"{name(rd)}, {name(rs3)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||FSR||
//--------------
//Instruction description:-
// The FSR instruction creates a 64-bit word by concatenating Rs1 and
//Rs3 (with Rs1 in the LSB half), rotate-right-shifts that word by the amount indicated in Rs2[5:0], and then writes the LSB half of the result to Rd.
//
//The FSRI instruction creates a 64-bit word by concatenating Rs1 and
//Rs3 (with Rs1 in the LSB half), rotate-right-shifts that word by the amount indicated in
//imm6u, and then writes the LSB half of the result to Rd.
//
//Instruction operation:-
//
//
// shamt = Rs2[5:0];  // FSR
// shamt = imm6u;     // FSRI
//
// lowpt = Rs1;
// highpt = Rs3;
// if (shamt u>= 32) {
//   shamt = shamt - 32;
//   lowpt = Rs3;
//   highpt = Rs1;
// }
// src[63:0] = CONCAT(highpt, lowpt);
// Rd = src[31+shamt:shamt];
// 
//Instruction syntax:-   FSR  Rd, Rs1, Rs3, Rs2
//Instruction formate:-
//None
    FSR {
        encoding: 0b:: rs3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b :: rd[4:0] :: 0b;
        args_disass:"{name(rd)}, {name(rs3)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||FSRW||
//--------------
//Instruction description:-
// The FSRW instruction creates a 64-bit word by concatenating the lower 32-bits of Rs1 and
//Rs3 (with Rs1 in the LSB half), rotate-right-shifts that word by the amount indicated in Rs2[5:0], and then sign-extends the 32-bit LSB half of the result and writes to Rd.
//
//Instruction operation:-
//
//
// shamt = Rs2[5:0];  // FSRW
// lowpt = Rs1.W[0];
// highpt = Rs3.W[0];
// if (shamt u>= 32) {
//   shamt = shamt - 32;
//   lowpt = Rs3.W[0];
//   highpt = Rs1.W[0];
// }
// src[63:0] = CONCAT(highpt, lowpt);
// wres = src[31+shamt:shamt];
// Rd = SE64(wres);
// 
//Instruction syntax:-   FSRW  Rd, Rs1, Rs3, Rs2
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    27 l|26  25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|Rs3 |FSRW +
//10 |Rs2 |Rs1 |FSRW +
//101 |Rd
//|OP-32 +
//0111011
//
    FSRW {
        encoding: 0b10:: rs3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b101 :: rd[4:0] :: 0b0111011;
        args_disass:"{name(rd)}, {name(rs3)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MAX||
//--------------
//Instruction description:-
// This instruction compares two signed integers stored in Rs1 and Rs2, picks the larger value as the result, and writes the result to Rd.
//
//Instruction operation:-
//
//
// if (Rs1 s>= Rs2) {
//   res = Rs1;
// } else {
//   res = Rs2;
// }
// Rd = res;
//
//Instruction syntax:-   MAX Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|0000101 |Rs2 |Rs1 |MAX +
//110 |Rd
//|OP +
//0110011
//
    MAX {
        encoding: 0b110 :: rs2[4:0] :: rs1[4:0] :: 0b0110011 :: rd[4:0] :: 0b;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MIN||
//--------------
//Instruction description:-
// This instruction compares two signed integers stored in Rs1 and Rs2, picks the smaller value as the result, and writes the result to Rd.
//
//Instruction operation:-
//
//
// if (Rs1 s>= Rs2) {
//   res = Rs2;
// } else {
//   res = Rs1;
// }
// Rd = res;
//
//Instruction syntax:-   MIN Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|0000101 |Rs2 |Rs1 |MIN +
//100 |Rd
//|OP +
//0110011
//
    MIN {
        encoding: 0b100 :: rs2[4:0] :: rs1[4:0] :: 0b0110011 :: rd[4:0] :: 0b;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||PACK||
//--------------
//Instruction description:-
//
//
//(PACK) The PACK instruction packs the XLEN/2-bit lower halves of rs1 and rs2 into rd, with rs1 in the lower half and rs2 in the upper half.
//
//(PACKU) The PACKU instruction packs the XLEN/2-bit upper halves of rs1 and rs2 into rd, with rs1 in the lower half and rs2 in the upper half.
//
//Instruction operation:-
//
//
//*RV32*
//
// Rd = CONCAT(Rs2.H[0], Rs1.H[0]); // PACK
// Rd = CONCAT(Rs2.H[1], Rs1.H[1]); // PACKU
//
//*RV64*
//
// Rd = CONCAT(Rs2.W[0], Rs1.W[0]); // PACK
// Rd = CONCAT(Rs2.W[1], Rs1.W[1]); // PACKU
//
//Instruction syntax:-   PACK  Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*PACK*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|PACK +
//0000100 |Rs2 |Rs1 |100 |Rd
//|OP +
//0110011
//|===
//
//[.text-center]
//*PACKU*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|PACKU +
//0100100 |Rs2 |Rs1 |100 |Rd
//|OP +
//0110011
//
    PACK {
        encoding: 0b0000100 :: rs2[4:0] :: rs1[4:0] :: 0b100 :: rd[4:0] :: 0b0110011;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||REV||
//--------------
//Instruction description:-
// This instruction reverses the XLEN bits of Rs1.
//
//Instruction operation:-
//
//
// rev[0:(XLEN-1)] = Rs1[(XLEN-1):0];
// Rd = rev[(XLEN-1):0];
//
//Instruction syntax:-   REV  Rd, Rs1
//Instruction formate:-
//[.text-center]
//*RV32*
//
//[cols="6*^.^"]
//|===
//l|31    26 l|25    20 l|19    15 l|14    12 l|11    7 l|6    0
//|GREVI +
//011010 |REV +
//011111 |Rs1 |101 |Rd
//|OP-IMM +
//0010011
//|===
//
//[.text-center]
//*RV64*
//
//[cols="6*^.^"]
//|===
//l|31    26 l|25    20 l|19    15 l|14    12 l|11    7 l|6    0
//|GREVI +
//011010 |REV +
//111111 |Rs1 |101 |Rd
//|OP-IMM +
//0010011
//
    REV {
        encoding: 0b011010 :: rs1[4:0] :: 0b011111 :: rd[4:0] :: 0b101;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||REV8||
//--------------
//Instruction description:-
// This instruction swaps the bytes within each halfword of Rs1 and writes the result to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = CONCAT(Rs1.H[x].B[0],Rs1.H[x].B[1]);
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   REV8.H  Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    26 l|25    20 l|19    15 l|14    12 l|11    7 l|6    0
//|GREVI +
//011010 |REV8H +
//001000 |Rs1 |101 |Rd
//|OP-IMM +
//0010011
//
    REV8 {
        encoding: 0b011010 :: rs1[4:0] :: 0b001000 :: rd[4:0] :: 0b101;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||ADD8||
//--------------
//Instruction description:-
// This instruction adds the 8-bit integer elements in Rs1 with the
//8-bit integer elements in Rs2, and then writes the 8-bit element results to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = Rs1.B[x] + Rs2.B[x];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   ADD8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ADD8 +
//0100100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    ADD8 {
        encoding: 0b0100100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||ADD16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit integer elements in Rs1 with the
//16-bit integer elements in Rs2, and then writes the 16-bit element results to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = Rs1.H[x] + Rs2.H[x];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   ADD16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ADD16 +
//0100000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    ADD16 {
        encoding: 0b0100000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||ADD64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//NoneInstruction syntax:-   ADD64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ADD64 +
//1100000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    ADD64 {
        encoding: 0b1100000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||AVE||
//--------------
//Instruction description:-
// This instruction calculates the average value of two signed integers
//stored in Rs1 and Rs2, rounds up a half-integer result to the nearest integer, and
//writes the result to Rd.
//
//Instruction operation:-
//
//
//*RV32:*
//
// res33 = SE33(Rs1) + SE33(Rs2) + SE33(1);
// Rd = res33[32:1];
//
//*RV64:*
//
// res65 = SE65(Rs1) + SE65(Rs2) + SE65(1);
// Rd = res65[64:1];
//
//Instruction syntax:-   AVE Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|AVE +
//1110000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    AVE {
        encoding: 0b1110000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||BITREV||
//--------------
//Instruction description:-
// This instruction reverses the bits of the content of Rs1. The reversed bit width is calculated as Rs2[4:0]+1 (RV32) or Rs2[5:0]+1 (RV64). The upper bits beyond the reversed width are filled with zeros. After the bit reverse operation, the result is written to Rd.
//
//Instruction operation:-
//
//
// msb = Rs2[4:0]; // RV32
// msb = Rs2[5:0]; // RV64
// rev[0:msb] = Rs1[msb:0];
// Rd = ZE32(rev[msb:0]);   // RV32
// Rd = ZE64(rev[msb:0]);   // RV64
//
//Instruction syntax:-   BITREV Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|BITREV +
//1110011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    BITREV {
        encoding: 0b1110011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||BITREVI||
//--------------
//Instruction description:-
// This instruction reverses the bits of the content of Rs1.
//The reversed bit width is calculated as imm5u+1 (RV32) or imm6u+1 (RV64).
//The upper bits beyond the reversed width are filled with zeros. After the bit reverse
//operation, the result is written to Rd.
//
//Instruction operation:-
//
//
// msb = imm5u; // RV32
// msb = imm6u; // RV64
// rev[0:msb] = Rs1[msb:0];
// Rd = ZE32(rev[msb:0]);   // RV32
// Rd = ZE64(rev[msb:0]);   // RV64
//
//Instruction syntax:-   BITREVI Rd, Rs1, imm5u (RV32)
//Instruction formate:-
//[.text-center]
//*RV32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|BITREVI +
//1110100 |imm5u |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*RV64*
//
//[cols="6*^.^"]
//|===
//l|31    26 l|25    20 l|19    15 l|14    12 l|11    7 l|6    0
//|BITREVI +
//111010 |imm6u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    BITREVI {
        encoding: 0b1110100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLROV||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//NoneInstruction syntax:-   CLROV # pseudo mnemonic
//Instruction formate:-
//None
    CLROV {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLRS8||
//--------------
//Instruction description:-
// Starting from the bits next to the sign bits of the 8-bit elements
//of Rs1, this instruction counts the number of redundant sign bits and writes the
//result to the corresponding 8-bit elements of Rd.
//
//Instruction operation:-
//
//
// snum[x] = Rs1.B[x];
// cnt[x] = 0;
// for (i = 6 to 0) {
//   if (snum[x](i) == snum[x](7)) {
//     cnt[x] = cnt[x] + 1;
//   } else {
//     break;
//   }
// }
// Rd.B[x] = cnt[x];
// for RV32: x=3..0
// for RV64: x=7..0
//
//Instruction syntax:-   CLRS8 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP2 +
//1010111 |CLRS8 +
//00000 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CLRS8 {
        encoding: 0b1010111 :: rs1[4:0] :: 0b00000 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLRS16||
//--------------
//Instruction description:-
// Starting from the bits next to the sign bits of the 16-bit elements
//of Rs1, this instruction counts the number of redundant sign bits and writes the
//result to the corresponding 16-bit elements of Rd.
//
//Instruction operation:-
//
//
// snum[x] = Rs1.H[x];
// cnt[x] = 0;
// for (i = 14 to 0) {
//   if (snum[x](i) == snum[x](15)) {
//     cnt[x] = cnt[x] + 1;
//   } else {
//     break;
//   }
// }
// Rd.H[x] = cnt[x];
// for RV32: x=1..0
// for RV64: x=3..0
//
//Instruction syntax:-   CLRS16 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP2 +
//1010111 |CLRS16 +
//01000 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CLRS16 {
        encoding: 0b1010111 :: rs1[4:0] :: 0b01000 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLRS32||
//--------------
//Instruction description:-
// Starting from the bits next to the sign bits of the 32-bit elements
//of Rs1, this instruction counts the number of redundant sign bits and writes the
//result to the corresponding 32-bit elements of Rd.
//
//Instruction operation:-
//
//
// snum[x] = Rs1.W[x];
// cnt[x] = 0;
// for (i = 30 to 0) {
//   if (snum[x](i) == snum[x](31)) {
//     cnt[x] = cnt[x] + 1;
//   } else {
//     break;
//   }
// }
// Rd.W[x] = cnt[x];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   CLRS32 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP2 +
//1010111 |CLRS32 +
//11000 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CLRS32 {
        encoding: 0b1010111 :: rs1[4:0] :: 0b11000 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLZ8||
//--------------
//Instruction description:-
// Starting from the most significant bits of the 8-bit elements
//of Rs1, this instruction counts the number of leading zero bits and writes the
//results to the corresponding 8-bit elements of Rd.
//
//Instruction operation:-
//
//
// snum[x] = Rs1.B[x];
// cnt[x] = 0;
// for (i = 7 to 0) {
//   if (snum[x](i) == 0) {
//     cnt[x] = cnt[x] + 1;
//   } else {
//     break;
//   }
// }
// Rd.B[x] = cnt[x];
// for RV32: x=3..0
// for RV64: x=7..0
//
//Instruction syntax:-   CLZ8 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP2 +
//1010111 |CLZ8 +
//00001 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CLZ8 {
        encoding: 0b1010111 :: rs1[4:0] :: 0b00001 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLZ16||
//--------------
//Instruction description:-
// Starting from the most significant bits of the 16-bit elements
//of Rs1, this instruction counts the number of leading zero bits and writes the
//results to the corresponding 16-bit elements of Rd.
//
//Instruction operation:-
//
//
// snum[x] = Rs1.H[x];
// cnt[x] = 0;
// for (i = 15 to 0) {
//   if (snum[x](i) == 0) {
//     cnt[x] = cnt[x] + 1;
//   } else {
//     break;
//   }
// }
// Rd.H[x] = cnt[x];
// for RV32: x=1..0
// for RV64: x=3..0
//
//Instruction syntax:-   CLZ16 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP2 +
//1010111 |CLZ16 +
//01001 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CLZ16 {
        encoding: 0b1010111 :: rs1[4:0] :: 0b01001 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CLZ32||
//--------------
//Instruction description:-
// Starting from the most significant bits of the 32-bit elements
//of Rs1, this instruction counts the number of leading zero bits and writes the
//results to the corresponding 32-bit elements of Rd.
//
//Instruction operation:-
//
//
// snum[x] = Rs1.W[x];
// cnt[x] = 0;
// for (i = 31 to 0) {
//   if (snum[x](i) == 0) {
//     cnt[x] = cnt[x] + 1;
//   } else {
//     break;
//   }
// }
// Rd.W[x] = cnt[x];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   CLZ32 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP2 +
//1010111 |CLZ32 +
//11001 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CLZ32 {
        encoding: 0b1010111 :: rs1[4:0] :: 0b11001 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CMPEQ8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit integer elements in Rs1 with
//the 8-bit integer elements in Rs2 to see if they are equal. If they are equal,
//the result is 0xFF; otherwise, the result is 0x0. The 8-bit element comparison
//results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] == Rs2.B[x])? 0xff : 0x0;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   CMPEQ8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|CMPEQ8 +
//0100111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CMPEQ8 {
        encoding: 0b0100111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CMPEQ16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit integer elements in Rs1 with
//the 16-bit integer elements in Rs2 to see if they are equal. If they are equal,
//the result is 0xFFFF; otherwise, the result is 0x0. The 16-bit element comparison
//results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] == Rs2.H[x])? 0xffff : 0x0;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   CMPEQ16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|CMPEQ16 +
//0100110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CMPEQ16 {
        encoding: 0b0100110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CRAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit integer element in [31:16] of
//32-bit chunks in Rs1 with the 16-bit integer element in [15:0] of 32-bit chunks
//in Rs2, and writes the result to [31:16] of 32-bit chunks in Rd; at the same
//time, it subtracts the 16-bit integer element in [31:16] of 32-bit chunks in
//Rs2 from the 16-bit integer element in [15:0] of 32-bit chunks, and writes the
//result to [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// Rd.W[x].H[1] = Rs1.W[x].H[1] + Rs2.W[x].H[0];
// Rd.W[x].H[0] = Rs1.W[x].H[0] � Rs2.W[x].H[1];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   CRAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|CRAS16 +
//0100010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CRAS16 {
        encoding: 0b0100010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CRSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit integer element in [15:0]
//of 32-bit chunks in Rs2 from the 16-bit integer element in [31:16] of 32-bit
//chunks in Rs1, and writes the result to [31:16] of 32-bit chunks in Rd; at the
//same time, it adds the 16-bit integer element in [31:16] of 32-bit chunks in
//Rs2 with the 16-bit integer element in [15:0] of 32-bit chunks in Rs1, and
//writes the result to [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// Rd.W[x].H[1] = Rs1.W[x].H[1] - Rs2.W[x].H[0];
// Rd.W[x].H[0] = Rs1.W[x].H[0] + Rs2.W[x].H[1];
// for RV32, x=0
// for RV64, x=1..0
//
//
//Instruction syntax:-   CRSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|CRSA16 +
//0100011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    CRSA16 {
        encoding: 0b0100011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||(||
//--------------
//Instruction description:-
// This instruction inserts byte 0 of Rs1 into byte �imm2u� (RV32)
//or �imm3u� (RV64) of Rd.
//
//Instruction operation:-
//
//
// bpos = imm2u;  // RV32
// bpos = imm3u;  // RV64
// Rd.B[bpos] = Rs1.B[0]
//
//Instruction syntax:-   (RV32) INSB Rd, Rs1, imm2u
//Instruction formate:-
//[.text-center]
//*RV32*
//
//[cols="8*^.^"]
//|===
//l|31    25 l|24    23 l|22 l|21    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110
//|INSB +
//00
//|0 |imm2u |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*RV64*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110
//|INSB +
//00
//|imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    ( {
        encoding: 0b1010110 :: rs2[4:0] :: rs1[4:0] :: 0b00 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KABS8||
//--------------
//Instruction description:-
// This instruction calculates the absolute value of 8-bit signed
//integer elements stored in Rs1 and writes the element results to Rd. If the input
//number is 0x80, this instruction generates 0x7f as the output and sets the OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.B[x];
// if (src == 0x80) {
//   src = 0x7f;
//   OV = 1;
// } else if (src[7] == 1)
//   src = -src;
// }
// Rd.B[x] = src;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   KABS8 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |KABS8 +
//10000 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KABS8 {
        encoding: 0b1010110 :: rs1[4:0] :: 0b10000 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KABS16||
//--------------
//Instruction description:-
// This instruction calculates the absolute value of 16-bit signed
//integer elements stored in Rs1 and writes the element results to Rd. If the
//input number is 0x8000, this instruction generates 0x7fff as the output and sets
//the OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.H[x];
// if (src == 0x8000) {
//   src = 0x7fff;
//   OV = 1;
// } else if (src[15] == 1)
//   src = -src;
// }
// Rd.H[x] = src;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   KABS16 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |KABS16 +
//10001 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KABS16 {
        encoding: 0b1010110 :: rs1[4:0] :: 0b10001 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KABSW||
//--------------
//Instruction description:-
// This instruction calculates the absolute value of a signed 32-bit
//integer stored in Rs1. The result is sign-extended (for RV64) and written to Rd.
//If the input is the minimum negative integer of 0x80000000, this instruction will produce a saturated 
//output of maximum positive integer of 0x7fffffff and the OV flag will be set to 1.
//
//Instruction operation:-
//
//
// if (Rs1.W[0] s>= 0) {
//   res = Rs1.W[0];
// } else {
//   If (Rs1.W[0] == 0x80000000) {
//     res = 0x7fffffff;
//     OV = 1;
//   } else {
//     res = -Rs1.W[0];
//   }
// }
// Rd = res;        // RV32
// Rd = SE64(res);  // RV64
//
//Instruction syntax:-   KABSW Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |KABSW +
//10100 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KABSW {
        encoding: 0b1010110 :: rs1[4:0] :: 0b10100 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KADD8||
//--------------
//Instruction description:-
// This instruction adds the 8-bit signed integer elements in Rs1
//with the 8-bit signed integer elements in Rs2. If any of the results exceed
//the Q7 number range (-2^7^ {le} Q7 {le} 2^7^-1), they are saturated to the range and
//the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// a9[x] = SE9(Rs1.B[x]);
// b9[x] = SE9(Rs2.B[x]);
// res9[x] = a9[x] + b9[x];
// if (res9[x] s> (2^7)-1) {
//   res9[x] = 127;
//   OV = 1;
// } else if (res9[x] s< -2^7) {
//   res9[x] = -128;
//   OV = 1;
// }
// Rd.B[x] = res9[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   KADD8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KADD8 +
//0001100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KADD8 {
        encoding: 0b0001100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KADD16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit signed integer elements in Rs1
//with the 16-bit signed integer elements in Rs2. If any of the results exceed
//the Q15 number range (-2^15^ {le} Q15 {le} 2^15^-1), they are saturated to the range
//and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// a17[x] = SE17(Rs1.H[x]);
// b17[x] = SE17(Rs2.H[x]);
// res17[x] = a17[x] + b17[x];
// if (res17[x] s> (2^15)-1) {
//   res17[x] = 32767;
//   OV = 1;
// } else if (res17[x] s< -(2^15)) {
//   res17[x] = -32768;
//   OV = 1;
// }
// Rd.H[x] = res17[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   KADD16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KADD16 +
//0001000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KADD16 {
        encoding: 0b0001000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KADD64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
// RV32:
//  t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
//  a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
//  b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
//  a65 = SE65(R[a_H].R[a_L]);
//  b65 = SE65(R[b_H].R[b_L]);
//  res65 = a65 + b65;
//  if (res65 s> (2^63)-1) {
//    res65 = (2^63)-1; OV = 1;
//  } else if (res65 s< -2^63) {
//    res65 = -2^63; OV = 1;
//  }
//  R[t_H].R[t_L] = res65.D[0];
//
// RV64:
//  a65 = SE65(Rs1);
//  b65 = SE65(Rs2);
//  res65 = a65 + b65;
//  if (res65 s> (2^63)-1) {
//    res65 = (2^63)-1; OV = 1;
//  } else if (res65 s< -2^63) {
//    res65 = -2^63; OV = 1;
//  }
//  Rd = res65.D[0];
//
//Instruction syntax:-   KADD64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KADD64 +
//1001000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KADD64 {
        encoding: 0b1001000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KADDH||
//--------------
//Instruction description:-
// The signed lower 16-bit content of Rs1 is added with the signed
//lower 16-bit content of Rs2. And the result is saturated to the 16-bit signed
//integer range of [-2^15^, 2^15^-1] and then sign-extended and written to Rd. If
//saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// a17 = SE17(Rs1.H[0]);
// b17 = SE17(Rs2.H[0]);
// res17 = a17 + b17;
// if (res17 s> (2^15)-1) {
//   res17 = (2^15)-1;
//   OV = 1;
// } else (res17 s< -2^15) {
//   res17 = -2^15;
//   OV = 1
// }
// Rd = SE32(res17.H[0]); // RV32
// Rd = SE64(res17.H[0]); // RV64
//
//
//Instruction syntax:-   KADDH Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KADDH +
//0000010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KADDH {
        encoding: 0b0000010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KADDW||
//--------------
//Instruction description:-
// The lower 32-bit signed content of Rs1 is added with the lower
//32-bit signed content of Rs2. And the result is saturated to the 32-bit signed
//integer range of [-2^31^, 2^31^-1] and then sign-extended and written to Rd. If
//saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// a33 = SE33(Rs1.W[0]);
// b33 = SE33(Rs2.W[0]);
// tmp33 = a33 + b33;
// if (tmp33 s> (2^31)-1) {
//   res32 = (2^31)-1;
//   OV = 1;
// } else if (tmp33 s< -2^31) {
//   re32 = -2^31;
//   OV = 1
// } else {
//   res32 = tmp33.W[0];
// }
// Rd = res32;       // RV32
// Rd = SE64(res32); // RV64
//
//Instruction syntax:-   KADDW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KADDW +
//0000000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KADDW {
        encoding: 0b0000000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KCRAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit signed integer element in [31:16]
//of 32-bit chunks in Rs1 with the 16-bit signed integer element in [15:0] of
//32-bit chunks in Rs2; at the same time, it subtracts the 16-bit signed integer
//element in [31:16] of 32-bit chunks in Rs2 from the 16-bit signed integer element
//in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the Q15
//number range (-2^15^ {le} Q15 {le} 2^15^-1), they are saturated to the range and the
//OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks
//in Rd for addition and [15:0] of 32-bit chunks in Rd for subtraction.
//
//Instruction operation:-
//
//
// a17[x] = SE17(Rs1.W[x].H[1]);
// b17[x] = SE17(Rs2.W[x].H[0]);
// c17[x] = SE17(Rs1.W[x].H[0]);
// d17[x] = SE17(Rs2.W[x].H[1]);
// res1 = a17[x] + b17[x];
// res2 = c17[x] � d17[x];
// for (res in [res1, res2]) {
//   if (res s> (2^15)-1) {
//     res = (2^15)-1;
//     OV = 1;
//   } else if (res s< -2^15) {
//     res = -2^15;
//     OV = 1;
//   }
// }
// Rd.W[x].H[1] = res1.H[0];
// Rd.W[x].H[0] = res2.H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//
//Instruction syntax:-   KCRAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KCRAS16 +
//0001010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KCRAS16 {
        encoding: 0b0001010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KCRSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit signed integer element in [15:0]
//of 32-bit chunks in Rs2 from the 16-bit signed integer element in [31:16]
//of 32-bit chunks in Rs1; at the same time, it adds the 16-bit signed integer
//element in [31:16] of 32-bit chunks in Rs2 with the 16-bit signed integer element
//in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the Q15 number
//range (-2^15^ {le} Q15 {le} 2^15^-1), they are saturated to the range and the OV bit is
//set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for
//subtraction and [15:0] of 32-bit chunks in Rd for addition.
//
//Instruction operation:-
//
//
// a17[x] = SE17(Rs1.W[x].H[1]);
// b17[x] = SE17(Rs2.W[x].H[0]);
// c17[x] = SE17(Rs1.W[x].H[0]);
// d17[x] = SE17(Rs2.W[x].H[1]);
// res1 = a17[x] - b17[x];
// res2 = c17[x] + d17[x];
// for (res in [res1, res2]) {
//   if (res s> (2^15)-1) {
//     res = (2^15)-1;
//     OV = 1;
//   } else if (res s< -2^15) {
//     res = -2^15;
//     OV = 1;
//   }
// }
// Rd.W[x].H[1] = res1.H[0];
// Rd.W[x].H[0] = res2.H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   KCRSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KCRSA16 +
//0001011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KCRSA16 {
        encoding: 0b0001011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KDMxy||
//--------------
//Instruction description:-
// Multiply the top or bottom 16-bit Q15 content of the lower 32-bit
//portion in Rs1 with the top or bottom 16-bit Q15 content of the lower 32-bit
//portion in Rs2. The Q30 result is then doubled and saturated into a Q31 value.
//The Q31 value is then written into Rd (sign-extended in RV64). When both the two
//Q15 inputs are 0x8000, saturation will happen. The result will be saturated to
//0x7FFFFFFF and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// aop = Rs1.H[0]; bop = Rs2.H[0]; // KDMBB
// aop = Rs1.H[0]; bop = Rs2.H[1]; // KDMBT
// aop = Rs1.H[1]; bop = Rs2.H[1]; // KDMTT
//
// If ((0x8000 != aop) || (0x8000 != bop)) {
//   resQ30[31:0] = aop s* bop;
//   shifted[31:0] = resQ30[31:0] << 1;
//   resQ31 = shifted[31:0];
//   Rd = resQ31;       // RV32
//   Rd = SE64(resQ31); // RV64
// } else {
//   resQ31 = 0x7FFFFFFF;
//   Rd = resQ31;       // RV32
//   Rd = SE64(resQ31); // RV64
//   OV = 1;
// }
//
//Instruction syntax:-   KDMxy Rd, Rs1, Rs2 (xy = BB, BT, TT)
//Instruction formate:-
//[.text-center]
//*KDMBB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMBB +
//0000101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMBT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMBT +
//0001101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMTT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMTT +
//0010101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KDMxy {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KDMAxy||
//--------------
//Instruction description:-
// Multiply the top or bottom 16-bit Q15 content of the lower 32-bit
//portion in Rs1 with the top or bottom 16-bit Q15 content of the lower 32-bit
//portion in Rs2. The Q30 result is then doubled and saturated into a Q31 value.
//The Q31 value is then added with the signed lower 32-bit word of Rd. If the addition result
//exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the
//range and the OV flag is set to 1. The result after saturation is sign-extended (for RV64) and written to Rd.
//
//When both the two Q15 inputs are 0x8000, saturation will happen and the overflow
//flag OV will be set.
//
//Instruction operation:-
//
//
// aop = Rs1.H[0]; bop = Rs2.H[0]; // KDMABB
// aop = Rs1.H[0]; bop = Rs2.H[1]; // KDMABT
// aop = Rs1.H[1]; bop = Rs2.H[1]; // KDMATT
// 
// If ((0x8000 != aop) || (0x8000 != bop)) {
//   resQ30[31:0] = aop s* bop;
//   shifted[31:0] = resQ30[31:0] << 1;
//   resQ31 = shifted[31:0];
// } else {
//   resQ31 = 0x7FFFFFFF;
//   OV = 1;
// }
// c33 = SE33(Rd.W[0]);
// d33 = SE33(resQ31);
// tmp33 = c33 + d33;
// if (tmp33 s> (2^31)-1) {
//   resadd32 = (2^31)-1;
//   OV = 1;
// } else if (tmp33 s< -2^31) {
//   resadd32 = -2^31;
//   OV = 1;
// } else {
//   resadd32 = tmp33.W[0];
// }
// Rd = resadd32;       // RV32
// Rd = SE64(resadd32); // RV64
//
//
//Instruction syntax:-   KDMAxy Rd, Rs1, Rs2 (xy = BB, BT, TT)
//Instruction formate:-
//[.text-center]
//*KDMABB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMABB +
//1101001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMABT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMABT +
//1110001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMATT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMATT +
//1111001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KDMAxy {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KHM8||
//--------------
//Instruction description:-
// For the �KHM8� instruction, multiply the _[.underline]#top#_ 8-bit
//Q7 content of 16-bit chunks in Rs1 with the _[.underline]#top#_ 8-bit Q7 content
//of 16-bit chunks in Rs2. At the same time, multiply the _[.underline]#bottom#_
//8-bit Q7 content of 16-bit chunks in Rs1 with the _[.underline]#bottom#_ 8-bit
//Q7 content of 16-bit chunks in Rs2.
//
//For the �KHMX8� instruction, multiply the _[.underline]#top#_ 8-bit Q7 content
//of 16-bit chunks in Rs1 with the _[.underline]#bottom#_ 8-bit Q7 content of 16-bit
//chunks in Rs2. At the same time, multiply the _[.underline]#bottom#_ 8-bit Q7
//content of 16-bit chunks in Rs1 with the _[.underline]#top#_ 8-bit Q7 content of
//16-bit chunks in Rs2.
//
//The Q14 results are then right-shifted 7-bits and saturated into Q7 values. The
//Q7 results are then written into Rd. When both the two Q7 inputs of a
//multiplication are 0x80, saturation will happen. The result will be saturated
//to 0x7F and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// if (is �KHM8�) {
//   op1t = Rs1.B[x+1]; op2t = Rs2.B[x+1]; // top
//   op1b = Rs1.B[x];   op2b = Rs2.B[x];   // bottom
// } else if (is �KHMX8�) {
//   op1t = Rs1.B[x+1]; op2t = Rs2.B[x];   // Rs1 top
//   op1b = Rs1.B[x];   op2b = Rs2.B[x+1]; // Rs1 bottom
// }
// for ((aop,bop,res16) in [(op1t,op2t,rest), (op1b,op2b,resb)]) {
//   if ((0x80 != aop) || (0x80 != bop)) {
//     mres[15:0] = aop s* bop;
//     rshifted[15:0] = mres[15:0] s>> 7;
//     res16 = rshifted[15:0];
//   } else {
//     res16= 0x007F;
//     OV = 1;
//   }
// }
// Rd.H[x/2] = concat(rest.B[0], resb.B[0]);
//
// for RV32, x=0,2
// for RV64, x=0,2,4,6
//
//Instruction syntax:-   KHM8 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KHM8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHM8 +
//1000111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KHMX8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMX8 +
//1001111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KHM8 {
        encoding: 0b1000111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KHM16||
//--------------
//Instruction description:-
// For the �KHM16� instruction, multiply the _[.underline]#top#_ 16-bit
//Q15 content of 32-bit chunks in Rs1 with the _[.underline]#top#_ 16-bit Q15 content
//of 32-bit chunks in Rs2. At the same time, multiply the _[.underline]#bottom#_ 16-bit
//Q15 content of 32-bit chunks in Rs1 with the _[.underline]#bottom#_ 16-bit Q15
//content of 32-bit chunks in Rs2.
//
//For the �KHMX16� instruction, multiply the _[.underline]#top#_ 16-bit Q15 content
//of 32-bit chunks in Rs1 with the _[.underline]#bottom#_ 16-bit Q15 content of
//32-bit chunks in Rs2. At the same time, multiply the _[.underline]#bottom#_ 16-bit
//Q15 content of 32-bit chunks in Rs1 with the _[.underline]#top#_ 16-bit Q15 content
//of 32-bit chunks in Rs2.
//
//The Q30 results are then right-shifted 15-bits and saturated into Q15 values. The
//Q15 results are then written into Rd. When both the two Q15 inputs of a
//multiplication are 0x8000, saturation will happen. The result will be saturated
//to 0x7FFF and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// if (is �KHM16�) {
//   op1t = Rs1.H[x+1]; op2t = Rs2.H[x+1]; // top
//   op1b = Rs1.H[x];   op2b = Rs2.H[x];   // bottom
// } else if (is �KHMX16�) {
//   op1t = Rs1.H[x+1]; op2t = Rs2.H[x];   // Rs1 top
//   op1b = Rs1.H[x];   op2b = Rs2.H[x+1]; // Rs1 bottom
// }
// for ((aop,bop,res32) in [(op1t,op2t,rest), (op1b,op2b,resb)]) {
//   if ((0x8000 != aop) || (0x8000 != bop)) {
//     mres[31:0] = aop s* bop;
//     rshifted[31:0] = mres[31:0] s>> 15;
//     res32 = rshifted[31:0];
//   } else {
//     res32= 0x00007FFF;
//     OV = 1;
//   }
// }
// Rd.W[x/2] = concat(rest.H[0], resb.H[0]);
//
// for RV32: x=0
// for RV64: x=0,2
//
//Instruction syntax:-   KHM16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KHM16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHM16 +
//1000011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KHMX16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMX16 +
//1001011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KHM16 {
        encoding: 0b1000011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KHMxy||
//--------------
//Instruction description:-
// Multiply the top or bottom 16-bit Q15 content of the lower 32-bit
//portion in Rs1 with the top or bottom 16-bit Q15 content of the lower 32-bit
//portion in Rs2. The Q30 result is then right-shifted 15-bits and saturated into
//a Q15 value. The Q15 value is then sing-extended and written into Rd. When both
//the two Q15 inputs are 0x8000, saturation will happen. The result will be
//saturated to 0x7FFF and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// aop = Rs1.H[0]; bop = Rs2.H[0]; // KHMBB
// aop = Rs1.H[0]; bop = Rs2.H[1]; // KHMBT
// aop = Rs1.H[1]; bop = Rs2.H[1]; // KHMTT
//
// If ((0x8000 != aop) || (0x8000 != bop)) {
//   res[31:0] = aop s* bop;
//   rshifted[31:0] = res[31:0] s>> 15;
//   Mres32 = rshifted[31:0];
// } else {
//   Mres32 = 0x00007FFF;
//   OV = 1;
// }
// Rd = SE32(Mres32.H[0]); // RV32
// Rd = SE64(Mres32.H[0]); // RV64
//
//Instruction syntax:-   KHMxy Rd, Rs1, Rs2 (xy = BB, BT, TT)
//Instruction formate:-
//[.text-center]
//*KHMBB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMBB +
//0000110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KHMBT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMBT +
//0001110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KHMTT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMTT +
//0010110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KHMxy {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMABB||
//--------------
//Instruction description:-
//
//
//For the �KMABB� instruction, it multiplies the _[.underline]#bottom#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#bottom#_ 16-bit content
//of 32-bit elements in Rs2.
//
//For the �KMABT� instruction, it multiplies the _[.underline]#bottom#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#top#_ 16-bit content
//of 32-bit elements in Rs2.
//
//For the �KMATT� instruction, it multiplies the _[.underline]#top#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#top#_ 16-bit content
//of 32-bit elements in Rs2.
//
//The multiplication result is added to the content of 32-bit elements in Rd. If
//the addition result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it
//is saturated to the range and the OV bit is set to 1. The results after
//saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as
//signed integers.
//
//Instruction operation:-
//
//
// mul32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[0]; // KMABB
// mul32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[1]; // KMABT
// mul32[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[1]; // KMATT
//
// res33[x] = SE33(Rd.W[x]) + SE33(mul32[x]);
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMABB Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMABB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMABB +
//0101101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMABT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMABT +
//0110101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMATT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMATT +
//0111101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMABB {
        encoding: 0b0101101 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMADA||
//--------------
//Instruction description:-
//
//
//For the �KMADA instruction, it multiplies the _[.underline]#bottom#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#bottom#_ 16-bit
//content of 32-bit elements in Rs2 and then adds the result to the result of
//multiplying the _[.underline]#top#_ 16-bit content of 32-bit elements in Rs1
//with the _[.underline]#top#_ 16-bit content of 32-bit elements in Rs2.
//
//For the �KMAXDA� instruction, it multiplies the _[.underline]#top#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#bottom#_ 16-bit content
//of 32-bit elements in Rs2 and then adds the result to the result of multiplying
//the _[.underline]#bottom#_ 16-bit content of 32-bit elements in Rs1 with the
//_[.underline]#top#_ 16-bit content of 32-bit elements in Rs2.
//
//The result is added to the content of 32-bit elements in Rd. If the addition
//result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated
//to the range and the OV bit is set to 1. The 32-bit results after saturation are
//written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//
// mula32[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[1]; // KMADA
// mulb32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[0]; //
// mula32[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[0]; // KMAXDA
// mulb32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[1]; //
//
// res34[x] = SE34(Rd.W[x]) + SE34(mula32[x]) + SE34(mulb32[x]);
// if (res34[x] s> (2^31)-1) {
//   res34[x] = (2^31)-1;
//   OV = 1;
// } else if (res34[x] s< -2^31) {
//   res34[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res34[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMADA Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMADA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMADA +
//0100100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMAXDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMAXDA +
//0100101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMADA {
        encoding: 0b0100100 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMADS||
//--------------
//Instruction description:-
//
//
//For the �KMADS� instruction, it multiplies the _[.underline]#bottom#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#bottom#_ 16-bit content
//of 32-bit elements in Rs2 and then subtracts the result from the result of
//multiplying the _[.underline]#top#_ 16-bit content of 32-bit elements in Rs1
//with the _[.underline]#top#_ 16-bit content of 32-bit elements in Rs2.
//
//For the �KMADRS� instruction, it multiplies the _[.underline]#top#_ 16-bit content
//of 32-bit elements in Rs1 with the _[.underline]#top#_ 16-bit content of 32-bit
//elements in Rs2 and then subtracts the result from the result of multiplying
//the _[.underline]#bottom#_ 16-bit content of 32-bit elements in Rs1 with
//the _[.underline]#bottom#_ 16-bit content of 32-bit elements in Rs2.
//
//For the �KMAXDS� instruction, it multiplies the _[.underline]#bottom#_ 16-bit
//content of 32-bit elements in Rs1 with the _[.underline]#top#_ 16-bit content
//of 32-bit elements in Rs2 and then subtracts the result from the result of
//multiplying the _[.underline]#top#_ 16-bit content of 32-bit elements in Rs1
//with the _[.underline]#bottom#_ 16-bit content of 32-bit elements in Rs2.
//
//The subtraction result is then added to the content of the corresponding 32-bit
//elements in Rd. If the addition result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1),
//it is saturated to the range and the OV bit is set to 1. The 32-bit results after
//saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as
//signed integers.
//
//Instruction operation:-
//
// 
// mula32[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[1]; // KMADS
// mulb32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[0]; //
// mula32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[0]; // KMADRS
// mulb32[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[1]; //
// mula32[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[0]; // KMAXDS
// mulb32[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[1]; //
//
// res34[x] = SE34(Rd.W[x]) + SE34(mula32[x]) - SE34(mulb32[x]);
// if (res34[x] s> (2^31)-1) {
//   res34[x] = (2^31)-1;
//   OV = 1;
// } else if (res34[x] s< -2^31) {
//   res34[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res34[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMADS Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMADS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMADS +
//0101110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMADRS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMADRS +
//0110110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMAXDS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMAXDS +
//0111110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMADS {
        encoding: 0b0101110 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMAR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// mul65 = SE65(Rs1 s* Rs2);
// top65 = SE65(R[t_H].R[t_L]);
// res65 = top65 + mul65;
// if (res65 s> (2^63)-1) {
//   res65 = (2^63)-1;
//   OV = 1;
// } else if (res65 s< -2^63) {
//   res65 = -2^63;
//   OV = 1;
// }
// R[t_H].R[t_L] = res65.D[0];
//
//*RV64:*
//
// mula66 = SE66(Rs1.W[0] s* Rs2.W[0]);
// mulb66 = SE66(Rs1.W[1] s* Rs2.W[1]);
// res66 = SE66(Rd) + mula66 + mulb66;
// if (res66 s> (2^63)-1) {
//   res66 = (2^63)-1;
//   OV = 1;
// } else if (res66 s< -2^63) {
//   res66 = -2^63;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   KMAR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMAR64 +
//1001010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMAR64 {
        encoding: 0b1001010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMDA||
//--------------
//Instruction description:-
//
//
//For the �KMDA� instruction, it multiplies the _[.underline]#bottom#_ 16-bit content
//of the 32-bit elements of Rs1 with the _[.underline]#bottom#_ 16-bit content of the
//32-bit elements of Rs2 and then adds the result to the result of multiplying
//the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs1 with the
//_[.underline]#top#_ 16-bit content of the 32-bit elements of Rs2.
//
//For the �KMXDA� instruction, it multiplies the _[.underline]#bottom#_ 16-bit content
//of the 32-bit elements of Rs1 with the _[.underline]#top#_ 16-bit content of the
//32-bit elements of Rs2 and then adds the result to the result of multiplying the
//_[.underline]#top#_ 16-bit content of the 32-bit elements of Rs1 with the
//_[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs2.
//
//The addition result is checked for saturation. If saturation happens, the result
//is saturated to 2^31^-1. The final results are written to Rd. The 16-bit contents
//are treated as signed integers.
//
//Instruction operation:-
//
//
// if ((Rs1.W[x] != 0x80008000) or (Rs2.W[x] != 0x80008000)) {
//   // KMDA
//   Rd.W[x] = (Rs1.W[x].H[1] s* Rs2.W[x].H[1]) + (Rs1.W[x].H[0] s* Rs2.W[x].H[0]);
//   // KMXDA
//   Rd.W[x] = (Rs1.W[x].H[1] s* Rs2.W[x].H[0]) + (Rs1.W[x].H[0] s* Rs2.W[x].H[1]);
// } else {
//   Rd.W[x] = 0x7fffffff;
//   OV = 1;
// }
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMDA Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMDA +
//0011100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMXDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMXDA +
//0011101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMDA {
        encoding: 0b0011100 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMAC||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit elements of Rs1 with the signed
//32-bit elements of Rs2 and adds the most significant 32-bit multiplication
//results with the signed 32-bit elements of Rd. If the addition result exceeds
//the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and
//the OV bit is set to 1. The results after saturation are written to Rd. The �.u�
//form of the instruction additionally rounds up the most significant 32-bit of the
//64-bit multiplication results by adding a 1 to bit 31 of the results.
//
//Instruction operation:-
//
//
// Mres[x][63:0] = Rs1.W[x] * Rs2.W[x];
// if (�.u� form) {
//   Round[x][32:0] = Mres[x][63:31] + 1;
//   res33[x] = SE33(Rd.W[x]) + SE33(Round[x][32:1]);
// } else {
//   res33[x] = SE33(Rd.W[x]) + SE33(Mres[x][63:32]);
// }
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMAC Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMAC*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAC +
//0110000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]s
//*KMMAC.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAC.u +
//0111000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMAC {
        encoding: 0b0110000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMAWB||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit elements of Rs1 with the signed bottom 16-bit content of the corresponding 32-bit elements of Rs2 and adds the most significant 32-bit multiplication results with the corresponding signed 32-bit elements of Rd. If the addition result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit multiplication results by adding a 1 to bit 15 of the result before the addition operations.
//
//Instruction operation:-
//
//
// Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[0];
// if ('.u' form) {
//   Round[x][32:0] = Mres[x][47:15] + 1;
//   res33[x] = SE33(Rd.W[x]) + SE33(Round[x][32:1]);
// } else {
//   res33[x] = SE33(Rd.W[x]) + SE33(Mres[x][47:16]);
// }
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMAWB Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMAWB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWB +
//0100011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMAWB.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWB.u +
//0101011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMAWB {
        encoding: 0b0100011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMAWB2||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit Q31 elements of Rs1 with the signed bottom 16-bit Q15 content of the corresponding 32-bit elements of Rs2, doubles the Q46 results to Q47 numbers and adds the saturated most significant 32-bit Q31 multiplication results with the corresponding signed 32-bit elements of Rd. If the addition result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit Q47 multiplication results by adding a 1 to bit 15 (i.e., bit 14 before doubling) of the result before the addition operations.
//
//Instruction operation:-
//
//
// if ((Rs1.W[x] != 0x80000000) or (Rs2.W[x].H[0] != 0x8000)) {
//   Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[0];
//   if ('.u' form) {
//     Mres[x][47:14] = Mres[x][47:14] + 1;
//   }
//   addop.W[x] = Mres[x][46:15]; // doubling
// } else {
//   addop.W[x] = 0x7fffffff;
//   OV = 1;
// }
// res33[x] = SE33(Rd.W[x]) + SE33(addop.W[x]);
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMAWB2 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMAWB2*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWB2 +
//1100111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMAWB2.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWB2.u +
//1101111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMAWB2 {
        encoding: 0b1100111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMAWT||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit elements of Rs1 with the signed top 16-bit of the corresponding 32-bit elements of Rs2 and adds the most significant 32-bit multiplication results with the corresponding signed 32-bit elements of Rd. If the addition result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit multiplication results by adding a 1 to bit 15 of the result before the addition operations.
//
//Instruction operation:-
//
//
// Mres[x][47:0] = Rs1.W[x] * Rs2.W[x].H[1];
// if (�.u� form) {
//   Round[x][32:0] = Mres[x][47:15] + 1;
//   res33[x] = SE33(Rd.W[x]) + SE33(Round[x][32:1]);
// } else {
//   res33[x] = SE33(Rd.W[x]) + SE33(Mres[x][47:16]);
// }
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMAWT Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMAWT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWT +
//0110011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMAWT.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWT.u +
//0111011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMAWT {
        encoding: 0b0110011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMAWT2||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit Q31 elements of Rs1 with the signed top 16-bit Q15 content of the corresponding 32-bit elements of Rs2, doubles the Q46 results to Q47 numbers and adds the saturated most significant 32-bit Q31 multiplication results with the corresponding signed 32-bit elements of Rd. If the addition result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit Q47 multiplication results by adding a 1 to bit 15 (i.e., bit 14 before doubling) of the result before the addition operations.
//
//Instruction operation:-
//
//
// if ((Rs1.W[x] == 0x80000000) && (Rs2.W[x].H[1] == 0x8000)) {
//   addop.W[x] = 0x7fffffff;
//   OV = 1;
// } else {
//   Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[1];
//   if (�.u� form) {
//     Mres[x][47:14] = Mres[x][47:14] + 1;
//   }
//   addop.W[x] = Mres[x][46:15]; // doubling
// }
// res33[x] = SE33(Rd.W[x]) + SE33(addop.W[x]);
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMAWT2 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMAWT2*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWT2 +
//1110111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMAWT2.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMAWT2.u +
//1111111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMAWT2 {
        encoding: 0b1110111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMSB||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit elements of Rs1 with the signed 32-bit elements of Rs2 and subtracts the most significant 32-bit multiplication results from the signed 32-bit elements of Rd. If the subtraction result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to Rd. The �.u� form of the instruction additionally rounds up the most significant 32-bit of the 64-bit multiplication results by adding a 1 to bit 31 of the results.
//
//Instruction operation:-
//
//
// Mres[x][63:0] = Rs1.W[x] * Rs2.W[x];
// if (�.u� form) {
//   Round[x][32:0] = Mres[x][63:31] + 1;
//   res33[x] = SE33(Rd.W[x]) - SE33(Round[x][32:1]);
// } else {
//   res33[x] = SE33(Rd.W[x]) - SE33(Mres[x][63:32]);
// }
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMSB Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMSB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMSB +
//0100001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMSB.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMSB.u +
//0101001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMSB {
        encoding: 0b0100001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMWB2||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit Q31 elements of Rs1 with the signed bottom 16-bit Q15 content of the corresponding 32-bit elements of Rs2, doubles the Q46 results to Q47 numbers and writes the saturated most significant 32-bit Q31 multiplication results to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit Q47 multiplication results by adding a 1 to bit 15 (i.e., bit 14 before doubling) of the results.
//
//Instruction operation:-
//
//
// if ((Rs1.W[x] == 0x80000000) && (Rs2.W[x].H[0] == 0x8000)) {
//   Rd.W[x] = 0x7fffffff;
//   OV = 1;
// } else {
//   Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[0];
//   if (�.u� form) {
//     Round[x][32:0] = Mres[x][46:14] + 1;
//     Rd.W[x] = Round[x][32:1];
//   } else {
//     Rd.W[x] = Mres[x][46:15];
//   }
// }
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMMWB2 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMWB2*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMWB2 +
//1000111
//|Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMWB2.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMWB2.u +
//1001111
//|Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMWB2 {
        encoding: 0b1000111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMMWT2||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit Q31 elements of Rs1 with the signed top 16-bit Q15 content of the corresponding 32-bit elements of Rs2, doubles the Q46 results to Q47 numbers and writes the saturated most significant 32-bit Q31 multiplication results to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit Q47 multiplication results by adding a 1 to bit 15 (i.e., bit 14 before doubling) of the results.
//
//Instruction operation:-
//
//
// if ((Rs1.W[x] == 0x80000000) && (Rs2.W[x].H[1] == 0x8000)) {
//   Rd.W[x] = 0x7fffffff;
//   OV = 1;
// } else {
//   Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[1];
//   if (�.u� form) {
//     Round[x][32:0] = Mres[x][46:14] + 1;
//     Rd.W[x] = Round[x][32:1];
//   } else {
//     Rd.W[x] = Mres[x][46:15];
//   }
// }
// for RV32: x=0
// for RV64: x=1..0
//
//
//Instruction syntax:-   KMMWT2 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMMWT2*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMWT2 +
//1010111
//|Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMMWT2.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMMWT2.u +
//1011111
//|Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMMWT2 {
        encoding: 0b1010111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMSDA||
//--------------
//Instruction description:-
//
//
//For the �KMSDA� instruction, it multiplies the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs2 and multiplies the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs2.
//
//For the �KMSXDA� instruction, it multiplies the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs2 and multiplies the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs2.
//
//The two 32-bit multiplication results are then subtracted from the content of the corresponding 32-bit elements of Rd. If the subtraction result exceeds the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to Rd. The 16-bit contents are treated as signed integers.
//
//Instruction operation:-
//
//
// mula34[x] = SE34(Rs1.W[x].H[1] s* Rs2.W[x].H[1]); // KMSDA
// mulb34[x] = SE34(Rs1.W[x].H[0] s* Rs2.W[x].H[0]); //
// mula34[x] = SE34(Rs1.W[x].H[1] s* Rs2.W[x].H[0]); // KMSXDA
// mulb34[x] = SE34(Rs1.W[x].H[0] s* Rs2.W[x].H[1]); //
// 
// res34[x] = SE34(Rd.W[x]) - mula34[x] - mulb34[x];
// if (res34[x] s> (2^31)-1) {
//   res34[x] = (2^31)-1;
//   OV = 1;
// } else if (res34[x] s< -2^31) {
//   res34[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res34[x].W[0];
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KMSDA Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMSDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMSDA +
//0100110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMSXDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMSXDA +
//0100111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMSDA {
        encoding: 0b0100110 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMSR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// mul65 = SE65(Rs1 s* Rs2);
// top65 = SE65(R[t_H].R[t_L]);
// res65 = top65 - mul65;
// if (res65 s> (2^63)-1) {
//   res65 = (2^63)-1; 
//   OV = 1;
// } else if (res65 s< -2^63) {
//   res65 = -2^63;
//   OV = 1;
// }
// R[t_H].R[t_L] = res65.D[0];
//
//
//*RV64:*
//
// mula66 = SE66(Rs1.W[0] s* Rs2.W[0]);
// mulb66 = SE66(Rs1.W[1] s* Rs2.W[1]);
// res66 = SE66(Rd) - mula66 - mulb66;
// if (res66 s> (2^63)-1) {
//   res66 = (2^63)-1;
//   OV = 1;
// } else if (res66 s< -2^63) {
//   res66 = -2^63;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   KMSR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMSR64 +
//1001011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KMSR64 {
        encoding: 0b1001011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLLW||
//--------------
//Instruction description:-
// The first word data in Rs1 is left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the low-order 5-bits of the value in the Rs2 register. Any shifted value greater than 2^31^-1 is saturated to 2^31^-1. Any shifted value smaller than -2^31^ is saturated to -2^31^. And the saturated result is sign-extended and written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = Rs2[4:0];
// res[(31+sa):0] = Rs1.W[0] << sa;
// if (res s> (2^31)-1) {
//   res = 0x7fffffff; OV = 1;
// } else if (res s< -2^31) {
//   res = 0x80000000; OV = 1;
// }
// Rd = res.W[0]; // RV32
// Rd = SE64(res.W[0]); // RV64
//
//Instruction syntax:-   KSLLW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLLW +
//0010011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSLLW {
        encoding: 0b0010011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLLIW||
//--------------
//Instruction description:-
// The first word data in Rs1 is left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm5u constant. Any shifted value greater than 2^31^-1 is saturated to 2^31^-1. Any shifted value smaller than -2^31^ is saturated to -2^31^. And the saturated result is sign-extended and written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = imm5u;
// res[(31+sa):0] = Rs1.W[0] << sa;
// if (res s> (2^31)-1) {
//   res = 0x7fffffff; OV = 1;
// } else if (res s< -2^31) {
//   res = 0x80000000; OV = 1;
// }
// Rd = res.W[0];       // RV32
// Rd = SE64(res.W[0]); // RV64
//
//Instruction syntax:-   KSLLIW Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLLIW +
//0011011 |imm5u |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSLLIW {
        encoding: 0b0011011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLL8||
//--------------
//Instruction description:-
// The 8-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the low-order 3-bits of the value in the Rs2 register. Any shifted value greater than 2^7^-1 is saturated to 2^7^-1. Any shifted value smaller than -2^7^ is saturated to -2^7^. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = Rs2[2:0];
// if (sa != 0) {
//   res[(7+sa):0] = Rs1.B[x] << sa;
//   if (res s> (2^7)-1) {
//     res = 0x7f; OV = 1;
//   } else if (res s< -2^7) {
//     res = 0x80; OV = 1;
//   }
//   Rd.B[x] = res.B[0];
// } else {
//   Rd = Rs1;
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   KSLL8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLL8 +
//0110110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSLL8 {
        encoding: 0b0110110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLLI8||
//--------------
//Instruction description:-
// The 8-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm3u constant. Any shifted value greater than 2^7^-1 is saturated to 2^7^-1. Any shifted value smaller than -2^7^ is saturated to -2^7^. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = imm3u;
// if (sa != 0) {
//   res[(7+sa):0] = Rs1.B[x] << sa;
//   if (res s> (2^7)-1) {
//     res = 0x7f; OV = 1;
//   } else if (res s< -2^7) {
//     res = 0x80; OV = 1;
//   }
//   Rd.B[x] = res.B[0];
// } else {
//   Rd = Rs1;
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//
//Instruction syntax:-   KSLLI8 Rd, Rs1, imm3u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLLI8 +
//0111110 |01 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSLLI8 {
        encoding: 0b0111110 :: rs2[4:0] :: rs1[4:0] :: 0b01 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLL16||
//--------------
//Instruction description:-
// The 16-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the low-order 4-bits of the value in the Rs2 register. Any shifted value greater than 2^15^-1 is saturated to 2^15^-1. Any shifted value smaller than -2^15^ is saturated to -2^15^. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = Rs2[3:0];
// if (sa != 0) {
//   res[(15+sa):0] = Rs1.H[x] << sa;
//   if (res s> (2^15)-1) {
//     res = 0x7fff; OV = 1;
//   } else if (res s< -2^15) {
//     res = 0x8000; OV = 1;
//   }
//   Rd.H[x] = res.H[0];
// } else {
//   Rd = Rs1;
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   KSLL16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLL16 +
//0110010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSLL16 {
        encoding: 0b0110010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLLI16||
//--------------
//Instruction description:-
// The 16-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm4u constant. Any shifted value greater than 2^15^-1 is saturated to 2^15^-1. Any shifted value smaller than -2^15^ is saturated to -2^15^. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = imm4u;
// if (sa != 0) {
//   res[(15+sa):0] = Rs1.H[x] << sa;
//   if (res s> (2^15)-1) {
//     res = 0x7fff; OV = 1;
//   } else if (res s< -2^15) {
//     res = 0x8000; OV = 1;
//   }
//   Rd.H[x] = res.H[0];
// } else {
//   Rd = Rs1;
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   KSLLI16 Rd, Rs1, imm4u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLLI16 +
//0111010 |1 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSLLI16 {
        encoding: 0b0111010 :: rs2[4:0] :: rs1[4:0] :: 0b1 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLRA8||
//--------------
//Instruction description:-
// The 8-bit data elements of Rs1 are left-shifted logically or right-shifted arithmetically based on the value of Rs2[3:0]. Rs2[3:0] is in the signed range of [-2^3^, 2^3^-1]. A positive Rs2[3:0] means logical left shift and a negative Rs2[3:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[3:0]. However, the behavior of �Rs2[3:0]==-2^3^ (0x8)� is defined to be equivalent to the behavior of �Rs2[3:0]==-(2^3^-1) (0x9)�.
//
//The left-shifted results are saturated to the 8-bit signed integer range of [-2^7^, 2^7^-1]. For the �.u� form of the instruction, the right-shifted results are added a 1 to the most significant discarded bit position for rounding effect. After the shift, saturation, or rounding, the final results are written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:4] will not affect this instruction.
//
//Instruction operation:-
//
//
// if (Rs2[3:0] s< 0) {
//   sa = -Rs2[3:0];
//   sa = (sa == 8)? 7 : sa;
//   if (�.u� form) {
//     res[7:-1] = SE9(Rs1.B[x][7:sa-1]) + 1;
//     Rd.B[x] = res[7:0];
//   } else {
//     Rd.B[x] = SE8(Rs1.B[x][7:sa]);
//   }
// } else {
//   sa = Rs2[2:0];
//   res[(7+sa):0] = Rs1.B[x] u<< sa;
//   if (res s> (2^7)-1) {
//     res[7:0] = 0x7f; OV = 1;
//   } else if (res s< -2^7) {
//     res[7:0] = 0x80; OV = 1;
//   }
//   Rd.B[x] = res[7:0];
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//
//Instruction syntax:-   KSLRA8 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KSLRA8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRA8 +
//0101111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KSLRA8.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRA8.u +
//0110111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSLRA8 {
        encoding: 0b0101111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLRA16||
//--------------
//Instruction description:-
// The 16-bit data elements of Rs1 are left-shifted logically or right-shifted arithmetically based on the value of Rs2[4:0]. Rs2[4:0] is in the signed range of [-2^4^, 2^4^-1]. A positive Rs2[4:0] means logical left shift and a negative Rs2[4:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[4:0]. However, the behavior of �Rs2[4:0]==-2^4^ (0x10)� is defined to be equivalent to the behavior of �Rs2[4:0]==-(2^4^-1) (0x11)�.
//
//The left-shifted results are saturated to the 16-bit signed integer range of [-2^15^, 2^15^-1]. For the �.u� form of the instruction, the right-shifted results are added a 1 to the most significant discarded bit position for rounding effect. After the shift, saturation, or rounding, the final results are written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:5] will not affect this instruction.
//
//Instruction operation:-
//
//
// if (Rs2[4:0] s< 0) {
//   sa = -Rs2[4:0];
//   sa = (sa == 16)? 15 : sa;
//   if (�.u� form) {
//     res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
//     Rd.H[x] = res[15:0];
//   } else {
//     Rd.H[x] = SE16(Rs1.H[x][15:sa]);
//   }
// } else {
//   sa = Rs2[3:0];
//   res[(15+sa):0] = Rs1.H[x] u<< sa;
//   if (res s> (2^15)-1) {
//     res[15:0] = 0x7fff; OV = 1;
//   } else if (res s< -2^15) {
//     res[15:0] = 0x8000; OV = 1;
//   }
//   d.H[x] = res[15:0];
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   KSLRA16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KSLRA16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRA16 +
//0101011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KSLRA16.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRA16.u +
//0110011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSLRA16 {
        encoding: 0b0101011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLRAW||
//--------------
//Instruction description:-
// The lower 32-bit content of Rs1 is left-shifted logically or right-shifted arithmetically based on the value of Rs2[5:0]. Rs2[5:0] is in the signed range of [-2^5^, 2^5^-1]. A positive Rs2[5:0] means logical left shift and a negative Rs2[5:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[5:0] clamped to the actual shift range of [0, 31].
//
//The left-shifted result is saturated to the 32-bit signed integer range of [-2^31^, 2^31^-1]. After the shift operation, the final result is bit-31 sign-extended and written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:6] will not affected the operation of this instruction.
//
//Instruction operation:-
//
//
// if (Rs2[5:0] s< 0) {
//   sa = -Rs2[5:0];
//   sa = (sa == 32)? 31 : sa;
//   res[31:0] = Rs1.W[0] s>> sa;
// } else {
//   sa = Rs2[5:0];
//   tmp[(31+sa):0] = Rs1.W[0] u<< sa;
//   if (tmp s> (2^31)-1) {
//     res[31:0] = (2^31)-1;
//     OV = 1;
//   } else if (tmp s< -2^31) {
//     res[31:0] = -2^31;
//     OV = 1
//   } else {
//     res[31:0] = tmp[31:0];
//   }
// }
// Rd = res[31:0]; // RV32
// Rd = SE64(res[31:0]); // RV64
//
//Instruction syntax:-   KSLRAW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRAW +
//0110111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSLRAW {
        encoding: 0b0110111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLRAW||
//--------------
//Instruction description:-
// The lower 32-bit content of Rs1 is left-shifted logically or right-shifted arithmetically based on the value of Rs2[5:0]. Rs2[5:0] is in the signed range of [-2^5^, 2^5^-1]. A positive Rs2[5:0] means logical left shift and a negative Rs2[5:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[5:0] clamped to the actual shift range of [0, 31].
//
//The left-shifted result is saturated to the 32-bit signed integer range of [-2^31^, 2^31^-1]. The right-shifted result is added a 1 to the most significant discarded bit position for rounding effect. After the shift, saturation, or rounding, the final result is bit-31 sign-extended and written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:6] will not affect the operation of this instruction.
//
//Instruction operation:-
//
//
// if (Rs2[5:0] s< 0) {
//   sa = -Rs2[5:0];
//   sa = (sa == 32)? 31 : sa;
//   res[31:-1] = SE33(Rs1[31:(sa-1)]) + 1;
//   rst[31:0] = res[31:0];
// } else {
//   sa = Rs2[5:0];
//   tmp[(31+sa):0] = Rs1.W[0] u<< sa;
//   if (tmp s> (2^31)-1) {
//     rst[31:0] = (2^31)-1;
//     OV = 1;
//   } else if (tmp s< -2^31) {
//     rst[31:0] = -2^31;
//     OV = 1
//   } else {
//     rst[31:0] = tmp[31:0];
//   }
// }
// Rd = rst[31:0]; // RV32
// Rd = SE64(rst[31:0]); // RV64
//
//Instruction syntax:-   KSLRAW.u Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRAW.u +
//0111111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSLRAW {
        encoding: 0b0111111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSTAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs1 with the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs2; at the same time, it subtracts the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs2 from the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the Q15 number range (-2^15^ {le} Q15 {le} 2^15^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for addition and [15:0] of 32-bit chunks in Rd for subtraction.
//
//Instruction operation:-
//
//
// res1[x] = SE17(Rs1.W[x].H[1]) + SE17(Rs2.W[x].H[1]);
// res2[x] = SE17(Rs1.W[x].H[0]) � SE17(Rs2.W[x].H[0]);
// for (res[x] in [res1[x], res2[x]]) {
//   if (res[x] s> (2^15)-1) {
//     res[x] = (2^15)-1;
//     OV = 1;
//   } else if (res[x] s< -2^15) {
//     res[x] = -2^15;
//     OV = 1;
//   }
// }
// Rd.W[x].H[1] = res1[x].H[0];
// Rd.W[x].H[0] = res2[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   KSTAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSTAS16 +
//1100010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSTAS16 {
        encoding: 0b1100010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSTSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs2 from the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs1; at the same time, it adds the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs2 with the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the Q15 number range (-2^15^ {le} Q15 {le} 2^15^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for subtraction and [15:0] of 32-bit chunks in Rd for addition.
//
//Instruction operation:-
//
//
// res1[x] = SE17(Rs1.W[x].H[1]) - SE17(Rs2.W[x].H[1]);
// res2[x] = SE17(Rs1.W[x].H[0]) + SE17(Rs2.W[x].H[0]);
// for (res[x] in [res1[x], res2[x]]) {
//   if (res[x] s> (2^15)-1) {
//     res[x] = (2^15)-1;
//     OV = 1;
//   } else if (res[x] s< -2^15) {
//     res[x] = -2^15;
//     OV = 1;
//   }
// }
// Rd.W[x].H[1] = res1[x].H[0];
// Rd.W[x].H[0] = res2[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   KSTSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSTSA16 +
//1100011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSTSA16 {
        encoding: 0b1100011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSUB8||
//--------------
//Instruction description:-
// This instruction subtracts the 8-bit signed integer elements in Rs2 from the 8-bit signed integer elements in Rs1. If any of the results exceed the Q7 number range (-2^7^ {le} Q7 {le} 2^7^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = SE9(Rs1.B[x]) - SE9(Rs2.B[x]);
// if (res[x] s> (2^7)-1) {
//   res[x] = (2^7)-1;
//   OV = 1;
// } else if (res[x] s< -2^7) {
//   res[x] = -2^7;
//   OV = 1;
// }
// Rd.B[x] = res[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   KSUB8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSUB8 +
//0001101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSUB8 {
        encoding: 0b0001101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSUB16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit signed integer elements in Rs2 from the 16-bit signed integer elements in Rs1. If any of the results exceed the Q15 number range (-2^15^ {le} Q15 {le} 2^15^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = SE17(Rs1.H[x]) - SE17(Rs2.H[x]);
// if (res[x] s> (2^15)-1) {
//   res[x] = (2^15)-1;
//   OV = 1;
// } else if (res[x] s< -2^15) {
//   res[x] = -2^15;
//   OV = 1;
// }
// Rd.H[x] = res[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   KSUB16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSUB16 +
//0001001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KSUB16 {
        encoding: 0b0001001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSUB64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = SE65(R[a_H].R[a_L]) - SE65(R[b_H].R[b_L]);
// if (res65 s> (2^63)-1) {
//   res65 = (2^63)-1; OV = 1;
// } else if (res65 s< -2^63) {
//   res65 = -2^63; OV = 1;
// }
// R[t_H].R[t_L] = res65.D[0];
//
//*RV64:*
//
// res65 = SE65(Rs1) � SE65(Rs2);
// if (res65 s> (2^63)-1) {
//   res65 = (2^63)-1; OV = 1;
// } else if (res65 s< -2^63) {
//   res65 = -2^63; OV = 1;
// }
// Rd = res65.D[0];
//
//Instruction syntax:-   KSUB64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSUB64 +
//1001001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSUB64 {
        encoding: 0b1001001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSUBH||
//--------------
//Instruction description:-
// The signed lower 16-bit content of Rs2 is subtracted from the signed lower 16-bit content of Rs1. And the result is saturated to the 16-bit signed integer range of [-2^15^, 2^15^-1] and then sign-extended and written to Rd. If saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// a17 = SE17(Rs1.H[0]);
// b17 = SE17(Rs2.H[0]);
// t17 = a17 - b17;
// if (t17 s> (2^15)-1) {
//   t17 = (2^15)-1;
//   OV = 1;
// } else (t17 s< -2^15) {
//   t17 = -2^15;
//   OV = 1
// }
// Rd = SE32(t17.H[0]);  // RV32
// Rd = SE64(t17.H[0]);  // RV64
//
//Instruction syntax:-   KSUBH Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSUBH +
//0000011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSUBH {
        encoding: 0b0000011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSUBW||
//--------------
//Instruction description:-
// The signed lower 32-bit content of Rs2 is subtracted from the signed lower 32-bit content of Rs1. And the result is saturated to the 32-bit signed integer range of [-2^31^, 2^31^-1] and then sign-extened and written to Rd. If saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// res33 = SE33(Rs1.W[0]) - SE33(Rs2.W[0]);
// if (res33 s> (2^31)-1) {
//   res33 = (2^31)-1;
//   OV = 1;
// } else if (res33 s< -2^31) {
//   res33 = -2^31;
//   OV = 1
// }
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   KSUBW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSUBW +
//0000001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KSUBW {
        encoding: 0b0000001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KWMMUL||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the 32-bit elements of Rs1 with the 32-bit elements of Rs2. It then shifts the multiplication results one bit to the left and takes the most significant 32-bit results. If the shifted result is greater than 2^31^-1, it is saturated to 2^31^-1 and the OV flag is set to 1. The final element result is written to Rd. The 32-bit elements of Rs1 and Rs2 are treated as signed integers. The �.u� form of the instruction additionally rounds up the 64-bit multiplication results by adding a 1 to bit 30 before the shift and saturation operations.
//
//Instruction operation:-
//
//
// if ((0x80000000 != Rs1.W[x]) || (0x80000000 != Rs2.W[x])) {
//   Mres[x][63:0] = Rs1.W[x] s* Rs2.W[x];
//   if (�.u� form) {
//     Round[x][33:0] = Mres[x][63:30] + 1;
//     Rd.W[x] = Round[x][32:1];
//   } else {
//     Rd.W[x] = Mres[x][62:31];
//   }
// } else {
//   Rd.W[x] = 0x7fffffff;
//   OV = 1;
// }
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   KWMMUL Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KWMMUL*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KWMMUL +
//0110001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KWMMUL.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KWMMUL.u +
//0111001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KWMMUL {
        encoding: 0b0110001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MADDR32||
//--------------
//Instruction description:-
// This instruction multiplies the lower 32-bit content of Rs1 with that of Rs2. It adds the lower 32-bit multiplication result to the lower 32-bit content of Rd and writes the final result (RV32) or sign-extended result (RV64) back to Rd. The contents of Rs1 and Rs2 can be either signed or unsigned integers.
//
//Instruction operation:-
//
//
//*RV32:*
//
// Mresult = Rs1 * Rs2;
// Rd = Rd + Mresult.W[0];  // overflow ignored
//
//*RV64:*
//
// Mresult = Rs1.W[0] * Rs2.W[0];
// tres[31:0] = Rd.W[0] + Mresult.W[0];  // overflow ignored
// Rd = SE64(tres[31:0]);
//
//Instruction syntax:-   MADDR32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MADDR32 +
//1100010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    MADDR32 {
        encoding: 0b1100010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MSUBR32||
//--------------
//Instruction description:-
// This instruction multiplies the lower 32-bit content of Rs1 with that of Rs2, subtracts the lower 32-bit multiplication result from the lower 32-bit content of Rd, then writes the final result (RV32) or sign-extended result (RV64) back to Rd. The contents of Rs1 and Rs2 can be either signed or unsigned integers.
//
//Instruction operation:-
//
//
//*RV32:*
//
// Mresult = Rs1 * Rs2;
// Rd = Rd - Mresult.W[0];  // overflow ignored
//
//*RV64:*
//
// Mresult = Rs1.W[0] * Rs2.W[0];
// tres[31:0] = Rd.W[0] - Mresult.W[0];  // overflow ignored
// Rd = SE64(tres[31:0]);
//
//Instruction syntax:-   MSUBR32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MSUBR32 +
//1100011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    MSUBR32 {
        encoding: 0b1100011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MULR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// Mresult = ZE33(Rs1) u* ZE33(Rs2);
// R[Rd(4,1).1(0)][31:0] = Mresult[63:32];
// R[Rd(4,1).0(0)][31:0] = Mresult[31:0];
//
//*RV64:*
//
// Mresult = ZE33(Rs1.W[0]) u* ZE33(Rs2.W[0]);
// Rd = Mresult[63:0];
//
//Instruction syntax:-   MULR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MULR64 +
//1111000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    MULR64 {
        encoding: 0b1111000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MULSR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// Mresult = Rs1 s* Rs2;
// R[Rd(4,1).1(0)][31:0] = Mresult[63:32];
// R[Rd(4,1).0(0)][31:0] = Mresult[31:0];
//
//*RV64:*
//
// Mresult = Rs1.W[0] s* Rs2.W[0];
// Rd = Mresult[63:0];
//
//Instruction syntax:-   MULSR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MULSR64 +
//1110000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    MULSR64 {
        encoding: 0b1110000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||PBSAD||
//--------------
//Instruction description:-
// This instruction subtracts the un-signed 8-bit elements of Rs2 from those of Rs1. Then it adds the absolute value of each difference together and writes the result to Rd.
//
//Instruction operation:-
//
//
// absdiff[x] = ABS(ZE9(Rs1.B[x]) � ZE9(Rs2.B[x]));
// Rd = SUM(ZE_XLEN(absdiff[x]));   // overflow ignored
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   PBSAD Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|PBSAD +
//1111110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    PBSAD {
        encoding: 0b1111110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||PBSADA||
//--------------
//Instruction description:-
// This instruction subtracts the un-signed 8-bit elements of Rs2 from those of Rs1. It then adds the absolute value of each difference together along with the content of Rd and writes the accumulated result back to Rd.
//
//Instruction operation:-
//
//
// absdiff[x] = ABS(ZE9(Rs1.B[x]) � ZE9(Rs2.B[x]));
// Rd = Rd + SUM(ZE_XLEN(absdiff[x]));  // overflow ignored
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   PBSADA Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|PBSADA +
//1111111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    PBSADA {
        encoding: 0b1111111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RV32||
//--------------
//Instruction description:-
//
//
//(PKBB16) moves Rs1.W[x].H[0] to Rd.W[x].H[1] and moves Rs2.W[x].H[0] to Rd.W[x].H[0].
//
//(PKBT16) moves Rs1.W[x].H[0] to Rd.W[x].H[1] and moves Rs2.W[x].H[1] to Rd.W[x].H[0].
//
//(PKTT16) moves Rs1.W[x].H[1] to Rd.W[x].H[1] and moves Rs2.W[x].H[1] to Rd.W[x].H[0].
//
//(PKTB16) moves Rs1.W[x].H[1] to Rd.W[x].H[1] and moves Rs2.W[x].H[0] to Rd.W[x].H[0].
//
//Instruction operation:-
//
//
// Rd.W[x] = CONCAT(Rs1.W[x].H[0], Rs2.W[x].H[0]); // PKBB16
// Rd.W[x] = CONCAT(Rs1.W[x].H[0], Rs2.W[x].H[1]); // PKBT16
// Rd.W[x] = CONCAT(Rs1.W[x].H[1], Rs2.W[x].H[0]); // PKTB16
// Rd.W[x] = CONCAT(Rs1.W[x].H[1], Rs2.W[x].H[1]); // PKTT16
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   RV32:
//Instruction formate:-
//None
    RV32 {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RADD8||
//--------------
//Instruction description:-
// This instruction adds the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2. The results are first arithmetically right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res9[x] = (SE9(Rs1.B[x]) + SE9(Rs2.B[x])) s>> 1;
// Rd.B[x] = res9[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   RADD8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RADD8 +
//0000100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    RADD8 {
        encoding: 0b0000100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RADD16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit signed integer elements in Rs1 with the 16-bit signed integer elements in Rs2. The results are first arithmetically right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res17[x] = (SE17(Rs1.H[x]) + SE17(Rs2.H[x])) s>> 1;
// Rd.H[x] = res17[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   RADD16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RADD16 +
//0000000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    RADD16 {
        encoding: 0b0000000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RADD64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = (SE65(R[a_H].R[a_L]) + SE65(R[b_H].R[b_L])) s>> 1;
// R[t_H].R[t_L] = res65.D[0];
//
//*RV64:*
//
// res65 = (SE65(Rs1) + SE65(Rs2)) s>> 1;
// Rd = res65.D[0];
//
//Instruction syntax:-   RADD64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RADD64 +
//1000000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    RADD64 {
        encoding: 0b1000000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RADDW||
//--------------
//Instruction description:-
// This instruction adds the first 32-bit signed integer in Rs1 with the first 32-bit signed integer in Rs2. The result is first arithmetically right-shifted by 1 bit and then sign-extended and written to Rd.
//
//Instruction operation:-
//
//
// res33 = (SE33(Rs1.W[0]) + SE33(Rs2.W[0])) s>> 1;
// 
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   RADDW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RADDW +
//0010000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    RADDW {
        encoding: 0b0010000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RCRAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs1 with the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs2, and subtracts the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs2 from the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs1. The element results are first arithmetically right-shifted by 1 bit and then written to [31:16] of 32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_add17[x] = (SE17(Rs1.W[x].H[1]) + SE17(Rs2.W[x].H[0])) s>> 1;
// res_sub17[x] = (SE17(Rs1.W[x].H[0]) � SE17(Rs2.W[x].H[1])) s>> 1;
// Rd.W[x].H[1] = res_add17[x].H[0];
// Rd.W[x].H[0] = res_sub17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   RCRAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RCRAS16 +
//0000010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    RCRAS16 {
        encoding: 0b0000010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RCRSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs2 from the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs1, and adds the 16-bit signed element integer in [15:0] of 32-bit chunks in Rs1 with the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs2. The two results are first arithmetically right-shifted by 1 bit and then written to [31:16] of 32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_sub17[x] = (SE17(Rs1.W[x].H[1]) - SE17(Rs2.W[x].H[0])) s>> 1;
// res_add17[x] = (SE17(Rs1.W[x].H[0]) + SE17(Rs2.W[x].H[1])) s>> 1;
// Rd.W[x].H[1] = res_sub17[x].H[0];
// Rd.W[x].H[0] = res_add17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   RCRSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RCRSA16 +
//0000011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    RCRSA16 {
        encoding: 0b0000011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RDOV||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//NoneInstruction syntax:-   RDOV Rd  # pseudo mnemonic
//Instruction formate:-
//[cols="5*^.^"]
//|===
//l|31    20 l|19    15 l|14    12 l|11    7 l|6    0
//|vxsat (ox009) +
//000000001001 |00000 |010 |Rd
//|SYSTEM +
//1110011
//
    RDOV {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSTAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs1 with the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs2, and subtracts the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs2 from the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs1. The element results are first arithmetically right-shifted by 1 bit and then written to [31:16] of 32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_add17[x] = (SE17(Rs1.W[x].H[1]) + SE17(Rs2.W[x].H[1])) s>> 1;
// res_sub17[x] = (SE17(Rs1.W[x].H[0]) � SE17(Rs2.W[x].H[0])) s>> 1;
// Rd.W[x].H[1] = res_add17[x].H[0];
// Rd.W[x].H[0] = res_sub17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   RSTAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSTAS16 +
//1011010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RSTAS16 {
        encoding: 0b1011010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSTSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs2 from the 16-bit signed integer element in [31:16] of 32-bit chunks in Rs1, and adds the 16-bit signed element integer in [15:0] of 32-bit chunks in Rs1 with the 16-bit signed integer element in [15:0] of 32-bit chunks in Rs2. The two results are first arithmetically right-shifted by 1 bit and then written to [31:16] of 32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_sub17[x] = (SE17(Rs1.W[x].H[1]) - SE17(Rs2.W[x].H[1])) s>> 1;
// res_add17[x] = (SE17(Rs1.W[x].H[0]) + SE17(Rs2.W[x].H[0])) s>> 1;
// Rd.W[x].H[1] = res_sub17[x].H[0];
// Rd.W[x].H[0] = res_add17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   RSTSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSTSA16 +
//1011011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RSTSA16 {
        encoding: 0b1011011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSUB8||
//--------------
//Instruction description:-
// This instruction subtracts the 8-bit signed integer elements in Rs2 from the 8-bit signed integer elements in Rs1. The results are first arithmetically right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res9[x] = (SE9(Rs1.B[x]) - SE9(Rs2.B[x])) s>> 1;
// Rd.B[x] = res9[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   RSUB8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSUB8 +
//0000101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    RSUB8 {
        encoding: 0b0000101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSUB16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit signed integer elements in Rs2 from the 16-bit signed integer elements in Rs1. The results are first arithmetically right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res17[x] = (SE17(Rs1.H[x]) - SE17(Rs2.H[x])) s>> 1;
// Rd.H[x] = res17[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   RSUB16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSUB16 +
//0000001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    RSUB16 {
        encoding: 0b0000001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSUB64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = (SE65(R[a_H].R[a_L]) - SE65(R[b_H].R[b_L])) s>> 1;
// R[t_H].R[t_L] = res65.D[0];
//
//*RV64:*
//
// Rd = (Rs1 - Rs2) s>> 1;
//
//Instruction syntax:-   RSUB64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSUB64 +
//1000001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    RSUB64 {
        encoding: 0b1000001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSUBW||
//--------------
//Instruction description:-
// This instruction subtracts the first 32-bit signed integer in Rs2 from the first 32-bit signed integer in Rs1. The result is first arithmetically right-shifted by 1 bit and then sign-extended and written to Rd.
//
//Instruction operation:-
//
//
// res33 = (SE33(Rs1.W[0]) - SE33(Rs2.W[0])) s>> 1;
//  
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   RSUBW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSUBW +
//0010001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    RSUBW {
        encoding: 0b0010001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SCLIP8||
//--------------
//Instruction description:-
// This instruction limits the 8-bit signed integer elements stored in Rs1 to a signed integer range between 2^imm3u^-1 and -2^imm3u^, and writes the limited results to Rd. For example, if imm3u is 3, the 8-bit input values should be saturated between 7 and -8. If saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.B[x];
// if (src s> (2^imm3u)-1) {
//   src = (2^imm3u)-1;
//   OV = 1;
// } else if (src s< -2^imm3u) {
//   src = -2^imm3u;
//   OV = 1;
// }
// Rd.B[x] = src
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SCLIP8 Rd, Rs1, imm3u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SCLIP8 +
//1000110 |00 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SCLIP8 {
        encoding: 0b1000110 :: rs2[4:0] :: rs1[4:0] :: 0b00 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SCLIP16||
//--------------
//Instruction description:-
// This instruction limits the 16-bit signed integer elements stored in Rs1 to a signed integer range between 2^imm4u^-1 and -2^imm4u^, and writes the limited results to Rd. For example, if imm4u is 3, the 16-bit input values should be saturated between 7 and -8. If saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.H[x];
// if (src s> (2^imm4u)-1) {
//   src = (2^imm4u)-1;
//   OV = 1;
// } else if (src s< -2^imm4u) {
//   src = -2^imm4u;
//   OV = 1;
// }
// Rd.H[x] = src
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SCLIP16 Rd, Rs1, imm4u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SCLIP16 +
//1000010 |0 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SCLIP16 {
        encoding: 0b1000010 :: rs2[4:0] :: rs1[4:0] :: 0b0 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SCLIP32||
//--------------
//Instruction description:-
// This instruction limits the 32-bit signed integer elements stored in Rs1 to a signed integer range between 2^imm5u^-1 and -2^imm5u^, and writes the limited results to Rd. For example, if imm5u is 3, the 32-bit input values should be saturated between 7 and -8. If saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.W[x];
// if (src s> (2^imm5u)-1) {
//   src = (2^imm5u)-1;
//   OV = 1;
// } else if (src s< -2^imm5u) {
//   src = -2^imm5u;
//   OV = 1;
// }
// Rd.W[x] = src
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   SCLIP32 Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SCLIP32 +
//1110010 |imm5u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SCLIP32 {
        encoding: 0b1110010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SCMPLE8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2 to see if the one in Rs1 is less than or equal to the one in Rs2. If it is true, the result is 0xFF; otherwise, the result is 0x0. The element comparison results are written to Rd
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] s<= Rs2.B[x])? 0xff : 0x0;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SCMPLE8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SCMPLE8 +
//0001111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SCMPLE8 {
        encoding: 0b0001111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SCMPLT8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2 to see if the one in Rs1 is less than the one in Rs2. If it is true, the result is 0xFF; otherwise, the result is 0x0. The element comparison results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] s< Rs2.B[x])? 0xff : 0x0;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SCMPLT8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SCMPLT8 +
//0000111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SCMPLT8 {
        encoding: 0b0000111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SCMPLT16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit signed integer elements in Rs1 with the two 16-bit signed integer elements in Rs2 to see if the one in Rs1 is less than the one in Rs2. If it is true, the result is 0xFFFF; otherwise, the result is 0x0. The element comparison results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] s< Rs2.H[x])? 0xffff : 0x0;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SCMPLT16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SCMPLT16 +
//0000110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SCMPLT16 {
        encoding: 0b0000110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SLL8||
//--------------
//Instruction description:-
// The 8-bit elements in Rs1 are left-shifted logically. And the results are written to Rd. The shifted out bits are filled with zero and the shift amount is specified by the low-order 3-bits of the value in the Rs2 register.
//
//Instruction operation:-
//
//
// sa = Rs2[2:0];
// Rd.B[x] = Rs1.B[x] << sa;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SLL8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SLL8 +
//0101110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SLL8 {
        encoding: 0b0101110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SLLI8||
//--------------
//Instruction description:-
// The 8-bit elements in Rs1 are left-shifted logically. And the results are written to Rd. The shifted out bits are filled with zero and the shift amount is specified by the imm3u constant.
//
//Instruction operation:-
//
//
// sa = imm3u;
// Rd.B[x] = Rs1.B[x] << sa;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SLLI8 Rd, Rs1, imm3u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SLLI8 +
//0111110 |00 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SLLI8 {
        encoding: 0b0111110 :: rs2[4:0] :: rs1[4:0] :: 0b00 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SLL16||
//--------------
//Instruction description:-
// The 16-bit elements in Rs1 are left-shifted logically. And the results are written to Rd. The shifted out bits are filled with zero and the shift amount is specified by the low-order 4-bits of the value in the Rs2 register.
//
//Instruction operation:-
//
//
// sa = Rs2[3:0];
// Rd.H[x] = Rs1.H[x] << sa;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SLL16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SLL16 +
//0101010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SLL16 {
        encoding: 0b0101010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SLLI16||
//--------------
//Instruction description:-
// The 16-bit elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm4u constant. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm4u;
// Rd.H[x] = Rs1.H[x] << sa;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SLLI16 Rd, Rs1, imm4u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SLLI16 +
//0111010 |0 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SLLI16 {
        encoding: 0b0111010 :: rs2[4:0] :: rs1[4:0] :: 0b0 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAL||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// Mres[31:0] = Rs2.H[1] s* Rs2.H[0];
// Idx0 = CONCAT(Rs1(4,1),1'b0); Idx1 = CONCAT(Rs1(4,1),1'b1);
// Idx2 = CONCAT(Rd(4,1),1'b0); Idx3 = CONCAT(Rd(4,1),1'b1);
// // overflow ignored
// R[Idx3].R[Idx2] = R[Idx1].R[Idx0] + SE64(Mres[31:0]);
//
//*RV64:*
//
// Mres[0][31:0] = Rs2.W[0].H[1] s* Rs2.W[0].H[0];
// Mres[1][31:0] = Rs2.W[1].H[1] s* Rs2.W[1].H[0];
// // overflow ignored
// Rd = Rs1 + SE64(Mres[1][31:0]) + SE64(Mres[0][31:0]);
//
//Instruction syntax:-   SMAL Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAL +
//0101111 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMAL {
        encoding: 0b0101111 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMALBB||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// Mres[31:0] = Rs1.H[0] s* Rs2.H[0]; // SMALBB
// Mres[31:0] = Rs1.H[0] s* Rs2.H[1]; // SMALBT
// Mres[31:0] = Rs1.H[1] s* Rs2.H[1]; // SMALTT
// Idx0 = CONCAT(Rd(4,1),1'b0); Idx1 = CONCAT(Rd(4,1),1'b1);
// // overflow ignored
// R[Idx1].R[Idx0] = R[Idx1].R[Idx0] + SE64(Mres[31:0]);
//
//
//*RV64:*
//
// // SMALBB
// Mres[0][31:0] = Rs1.W[0].H[0] s* Rs2.W[0].H[0];
// Mres[1][31:0] = Rs1.W[1].H[0] s* Rs2.W[1].H[0];
//
// // SMALBT
// Mres[0][31:0] = Rs1.W[0].H[0] s* Rs2.W[0].H[1];
// Mres[1][31:0] = Rs1.W[1].H[0] s* Rs2.W[1].H[1];
//
// // SMALTT
// Mres[0][31:0] = Rs1.W[0].H[1] s* Rs2.W[0].H[1];
// Mres[1][31:0] = Rs1.W[1].H[1] s* Rs2.W[1].H[1];
// // overflow ignored
// Rd = Rd + SE64(Mres[0][31:0]) + SE64(Mres[1][31:0]);
//
//Instruction syntax:-   SMALBB Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMALBB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALBB +
//1000100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMALBT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALBT +
//1001100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMALTT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALTT +
//1010100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMALBB {
        encoding: 0b1000100 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMALDA||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//*RV32:*
//
// // SMALDA
// Mres0[31:0] = (Rs1.H[0] s* Rs2.H[0]);
// Mres1[31:0] = (Rs1.H[1] s* Rs2.H[1]);
// // SMALXDA
// Mres0[31:0] = (Rs1.H[0] s* Rs2.H[1]);
// Mres1[31:0] = (Rs1.H[1] s* Rs2.H[0]);
//
// Idx0 = CONCAT(Rd(4,1),1'b0); Idx1 = CONCAT(Rd(4,1),1'b1);
// // overflow ignored
// R[Idx1].R[Idx0] = R[Idx1].R[Idx0] + SE64(Mres0[31:0]) + SE64(Mres1[31:0]);
//
//
//*RV64:*
//
// // SMALDA
// Mres0[0][31:0] = (Rs1.W[0].H[0] s* Rs2.W[0].H[0]);
// Mres1[0][31:0] = (Rs1.W[0].H[1] s* Rs2.W[0].H[1]);
// Mres0[1][31:0] = (Rs1.W[1].H[0] s* Rs2.W[1].H[0]);
// Mres1[1][31:0] = (Rs1.W[1].H[1] s* Rs2.W[1].H[1]);
// // SMALXDA
// Mres0[0][31:0] = (Rs1.W[0].H[0] s* Rs2.W[0].H[1]);
// Mres1[0][31:0] = (Rs1.W[0].H[1] s* Rs2.W[0].H[0]);
// Mres0[1][31:0] = (Rs1.W[1].H[0] s* Rs2.W[1].H[1]);
// Mres1[1][31:0] = (Rs1.W[1].H[1] s* Rs2.W[1].H[0]);
// 
// // overflow ignored
// Rd = Rd + SE64(Mres0[0][31:0]) + SE64(Mres1[0][31:0]) + SE64(Mres0[1][31:0]) + SE64(Mres1[1][31:0]);
//
//
//Instruction syntax:-   SMALDA Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMALDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALDA +
//1000110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMALXDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALXDA +
//1001110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMALDA {
        encoding: 0b1000110 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMALDS||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// // Q31 = Q30 - Q30 = Q15*Q15 - Q15*Q15, overflow ignored
// Mres[31:0] = (Rs1.H[1] s* Rs2.H[1]) - (Rs1.H[0] s* Rs2.H[0]); // SMALDS
// Mres[31:0] = (Rs1.H[0] s* Rs2.H[0]) - (Rs1.H[1] s* Rs2.H[1]); // SMALDRS
// Mres[31:0] = (Rs1.H[1] s* Rs2.H[0]) - (Rs1.H[0] s* Rs2.H[1]); // SMALXDS
//
// Idx0 = CONCAT(Rd(4,1),1'b0); Idx1 = CONCAT(Rd(4,1),1'b1);
// R[Idx1].R[Idx0] = R[Idx1].R[Idx0] + SE64(Mres[31:0]);  // overflow ignored
//
//* RV64:
//
// // Q31 = Q30 - Q30 = Q15*Q15 - Q15*Q15, overflow ignored
// // SMALDS
// Mres[0][31:0] = (Rs1.W[0].H[1] s* Rs2.W[0].H[1]) - (Rs1.W[0].H[0] s* Rs2.W[0].H[0]);
// Mres[1][31:0] = (Rs1.W[1].H[1] s* Rs2.W[1].H[1]) - (Rs1.W[1].H[0] s* Rs2.W[1].H[0]);
//
// // SMALDRS
// Mres[0][31:0] = (Rs1.W[0].H[0] s* Rs2.W[0].H[0]) - (Rs1.W[0].H[1] s* Rs2.W[0].H[1]);
// Mres[1][31:0] = (Rs1.W[1].H[0] s* Rs2.W[1].H[0]) - (Rs1.W[1].H[1] s* Rs2.W[1].H[1]);
//
// // SMALXDS
// Mres[0][31:0] = (Rs1.W[0].H[1] s* Rs2.W[0].H[0]) - (Rs1.W[0].H[0] s* Rs2.W[0].H[1]);
// Mres[1][31:0] = (Rs1.W[1].H[1] s* Rs2.W[1].H[0]) - (Rs1.W[1].H[0] s* Rs2.W[1].H[1]);
//
// Rd = Rd + SE64(Mres[0][31:0]) + SE64(Mres[1][31:0]);  // overflow ignored
//
//Instruction syntax:-   SMALDS Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMALDS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALDS +
//1000101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMALDRS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALDRS +
//1001101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMALXDS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMALXDS +
//1010101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMALDS {
        encoding: 0b1000101 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// R[d_H].R[d_L] = R[d_H].R[d_L] + (Rs1 s* Rs2);   // overflow discarded
//
//* RV64:
//
// Rd = Rd + (Rs1.W[0] s* Rs2.W[0]) + (Rs1.W[1] s* Rs2.W[1]);   // overflow discarded
//
//Instruction syntax:-   SMAR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAR64 +
//1000010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMAR64 {
        encoding: 0b1000010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAQA||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the four signed 8-bit elements of 32-bit chunks of Rs1 with the four signed 8-bit elements of 32-bit chunks of Rs2 and then adds the four results together with the signed content of the corresponding 32-bit chunks of Rd. The final results are written back to the corresponding 32-bit chunks in Rd.
//
//For this instruction, any potential overflow bits beyond 32-bit are discarded and ignored.
//
//Instruction operation:-
//
//
// res[x] = Rd.W[x] +
//    SE32(Rs1.W[x].B[3] s* Rs2.W[x].B[3]) + SE32(Rs1.W[x].B[2] s* Rs2.W[x].B[2]) +
//    SE32(Rs1.W[x].B[1] s* Rs2.W[x].B[1]) + SE32(Rs1.W[x].B[0] s* Rs2.W[x].B[0]);   // overflow discarded
// Rd.W[x] = res[x];
// for RV32: x=0,
// for RV64: x=1,0
//
//Instruction syntax:-   SMAQA Rd, Rs1, Rs2
//Instruction formate:-
//*SMAQA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAQA +
//1100100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMAQA {
        encoding: 0b1100100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAQA||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the four signed 8-bit elements of 32-bit chunks of Rs1 with the four unsigned 8-bit elements of 32-bit chunks of Rs2 and then adds the four results together with the signed content of the corresponding 32-bit chunks of Rd. The final results are written back to the corresponding 32-bit chunks in Rd.
//
//For this instruction, any potential overflow bits beyond 32-bit are discarded and ignored.
//
//Instruction operation:-
//
//
// res[x] = Rd.W[x] +
//    SE32(Rs1.W[x].B[3] su* Rs2.W[x].B[3]) + SE32(Rs1.W[x].B[2] su* Rs2.W[x].B[2]) +
//    SE32(Rs1.W[x].B[1] su* Rs2.W[x].B[1]) + SE32(Rs1.W[x].B[0] su* Rs2.W[x].B[0]);   // overflow discarded
// Rd.W[x] = res[x];
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   SMAQA.SU Rd, Rs1, Rs2
//Instruction formate:-
//*SMAQA.SU*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAQA.SU +
//1100101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMAQA {
        encoding: 0b1100101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAX8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2 and selects the numbers that is greater than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] s> Rs2.B[x])? Rs1.B[x] : Rs2.B[x];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SMAX8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAX8 +
//1000101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMAX8 {
        encoding: 0b1000101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAX16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit signed integer elements in Rs1 with the 16-bit signed integer elements in Rs2 and selects the numbers that is greater than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] s> Rs2.H[x])? Rs1.H[x] : Rs2.H[x];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SMAX16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAX16 +
//1000001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMAX16 {
        encoding: 0b1000001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMBB16||
//--------------
//Instruction description:-
//
//
//For the �SMBB16� instruction, it multiplies the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs2.
//
//For the �SMBT16� instruction, it multiplies the _[.underline]#bottom#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs2.
//
//For the �SMTT16� instruction, it multiplies the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs1 with the _[.underline]#top#_ 16-bit content of the 32-bit elements of Rs2.
//
//The multiplication results are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//
// Rd.W[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[0]; // SMBB16
// Rd.W[x] = Rs1.W[x].H[0] s* Rs2.W[x].H[1]; // SMBT16
// Rd.W[x] = Rs1.W[x].H[1] s* Rs2.W[x].H[1]; // SMTT16
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   SMBB16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMBB16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMBB16 +
//0000100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMBT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMBT16 +
//0001100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMTT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMTT16 +
//0010100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMBB16 {
        encoding: 0b0000100 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMDS||
//--------------
//Instruction description:-
//
//
//For the �SMDS� instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2.
//
//For the �SMDRS� instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2.
//
//For the �SMXDS� instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2.
//
//The subtraction result is written to the corresponding 32-bit element of Rd. The 16-bit contents of multiplication are treated as signed integers.
//
//Instruction operation:-
//
//
//* SMDS:
//
// Rd.W[x] = (Rs1.W[x].H[1] s* Rs2.W[x].H[1]) - (Rs1.W[x].H[0] s* Rs2.W[x].H[0]);
//
//* SMDRS:
//
// Rd.W[x] = (Rs1.W[x].H[0] s* Rs2.W[x].H[0]) - (Rs1.W[x].H[1] s* Rs2.W[x].H[1]);
//
//* SMXDS:
//
// Rd.W[x] = (Rs1.W[x].H[1] s* Rs2.W[x].H[0]) - (Rs1.W[x].H[0] s* Rs2.W[x].H[1]);
//
//Instruction syntax:-   SMDS Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMDS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMDS +
//0101100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMDRS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMDRS +
//0110100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMXDS*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMXDS +
//0111100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMDS {
        encoding: 0b0101100 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMIN8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit signed integer elements in Rs1 with the 8-bit signed integer elements in Rs2 and selects the numbers that is less than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] s< Rs2.B[x])? Rs1.B[x] : Rs2.B[x];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SMIN8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMIN8 +
//1000100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMIN8 {
        encoding: 0b1000100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMIN16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit signed integer elements in Rs1 with the 16-bit signed integer elements in Rs2 and selects the numbers that is less than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] s< Rs2.H[x])? Rs1.H[x] : Rs2.H[x];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SMIN16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMIN16 +
//1000000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMIN16 {
        encoding: 0b1000000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMMUL||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the 32-bit elements of Rs1 with the 32-bit elements of Rs2 and writes the most significant 32-bit multiplication results to the corresponding 32-bit elements of Rd. The 32-bit elements of Rs1 and Rs2 are treated as signed integers. The �.u� form of the instruction rounds up the most significant 32-bit of the 64-bit multiplication results by adding a 1 to bit 31 of the results.
//
//* For �smmul/RV32� instruction, it is an alias for �mulh/RV32� instruction.
//
//Instruction operation:-
//
//
// Mres[x][63:0] = Rs1.W[x] s* Rs2.W[x];
// if (�.u� form) {
//   Round[x][32:0] = Mres[x][63:31] + 1;
//   Rd.W[x] = Round[x][32:1];
// } else {
//   Rd.W[x] = Mres[x][63:32];
// }
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   SMMUL Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMMUL (RV32)*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MULH +
//0000001 |Rs2 |Rs1 |001 |Rd
//|OP +
//0110011
//|===
//
//[.text-center]
//*SMMUL (RV64)*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMMUL +
//0100000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMMUL.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMMUL.u +
//0101000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMMUL {
        encoding: 0b0000001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b0110011;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMMWB||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit elements of Rs1 with the signed bottom 16-bit content of the corresponding 32-bit elements of Rs2 and writes the most significant 32-bit multiplication results to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit multiplication results by adding a 1 to bit 15 of the results.
//
//Instruction operation:-
//
//
// Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[0];
// if (�.u� form) {
//   Round[x][32:0] = Mres[x][47:15] + 1;
//   Rd.W[x] = Round[x][32:1];
// } else {
//   Rd.W[x] = Mres[x][47:16];
// }
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   SMMWB Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMMWB*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMMWB +
//0100010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMMWB.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMMWB.u +
//0101010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMMWB {
        encoding: 0b0100010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMMWT||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the signed 32-bit elements of Rs1 with the top signed 16-bit content of the corresponding 32-bit elements of Rs2 and writes the most significant 32-bit multiplication results to the corresponding 32-bit elements of Rd. The �.u� form of the instruction rounds up the most significant 32-bit of the 48-bit multiplication results by adding a 1 to bit 15 of the results.
//
//Instruction operation:-
//
//
// Mres[x][47:0] = Rs1.W[x] s* Rs2.W[x].H[1];
// if (�.u� form) {
//   Round[x][32:0] = Mres[x][47:15] + 1;
//   Rd.W[x] = Round[x][32:1];
// } else {
//   Rd.W[x] = Mres[x][47:16];
// }
// for RV32: x=0
// for RV64: x=1..0
//
//Instruction syntax:-   SMMWT Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMMWT*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMMWT +
//0110010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMMWT.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMMWT.u +
//0111010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMMWT {
        encoding: 0b0110010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMSLDA||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// // SMSLDA
// Mres0[31:0] = (Rs1.H[0] s* Rs2.H[0]);
// Mres1[31:0] = (Rs1.H[1] s* Rs2.H[1]);
// // SMSLXDA
// Mres0[31:0] = (Rs1.H[0] s* Rs2.H[1]);
// Mres1[31:0] = (Rs1.H[1] s* Rs2.H[0]);
//
// Idx0 = CONCAT(Rd(4,1),1'b0); Idx1 = CONCAT(Rd(4,1),1'b1);
// R[Idx1].R[Idx0] = R[Idx1].R[Idx0] - SE64(Mres0[31:0]) - SE64(Mres1[31:0]);
//
//
//* RV64:
//
// // SMSLDA
// Mres0[0][31:0] = (Rs1.W[0].H[0] s* Rs2.W[0].H[0]);
// Mres1[0][31:0] = (Rs1.W[0].H[1] s* Rs2.W[0].H[1]);
// Mres0[1][31:0] = (Rs1.W[1].H[0] s* Rs2.W[1].H[0]);
// Mres1[1][31:0] = (Rs1.W[1].H[1] s* Rs2.W[1].H[1]);
// // SMSLXDA
// Mres0[0][31:0] = (Rs1.W[0].H[0] s* Rs2.W[0].H[1]);
// Mres1[0][31:0] = (Rs1.W[0].H[1] s* Rs2.W[0].H[0]);
// Mres0[1][31:0] = (Rs1.W[1].H[0] s* Rs2.W[1].H[1]);
// Mres1[1][31:0] = (Rs1.W[1].H[1] s* Rs2.W[1].H[0]);
//
// Rd = Rd - SE64(Mres0[0][31:0]) - SE64(Mres1[0][31:0]) - SE64(Mres0[1][31:0]) - SE64(Mres1[1][31:0]);
//
//Instruction syntax:-   SMSLDA Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMSLDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMSLDA +
//1010110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMSLXDA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMSLXDA +
//1011110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMSLDA {
        encoding: 0b1010110 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMSR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// R[d_H].R[d_L] = R[d_H].R[d_L] - (Rs1 s* Rs2);
//
//* RV64:
//
// Rd = Rd - (Rs1.W[0] s* Rs2.W[0]) - (Rs1.W[1] s* Rs2.W[1]);
//
//Instruction syntax:-   SMSR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMSR64 +
//1000011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SMSR64 {
        encoding: 0b1000011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMUL8||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// // SMUL8
// R[d_L].H[0] = Rs1.B[0] s* Rs2.B[0];
// R[d_L].H[1] = Rs1.B[1] s* Rs2.B[1];
// R[d_H].H[0] = Rs1.B[2] s* Rs2.B[2];
// R[d_H].H[1] = Rs1.B[3] s* Rs2.B[3];
// // SMULX8
// R[d_L].H[0] = Rs1.B[0] s* Rs2.B[1];
// R[d_L].H[1] = Rs1.B[1] s* Rs2.B[0];
// R[d_H].H[0] = Rs1.B[2] s* Rs2.B[3];
// R[d_H].H[1] = Rs1.B[3] s* Rs2.B[2];
//
//* RV64:
//
// // SMUL8
// Rd.W[0].H[0] = Rs1.B[0] s* Rs2.B[0];
// Rd.W[0].H[1] = Rs1.B[1] s* Rs2.B[1];
// Rd.W[1].H[0] = Rs1.B[2] s* Rs2.B[2];
// Rd.W[1].H[1] = Rs1.B[3] s* Rs2.B[3];
// // SMULX8
// Rd.W[0].H[0] = Rs1.B[0] s* Rs2.B[1];
// Rd.W[0].H[1] = Rs1.B[1] s* Rs2.B[0];
// Rd.W[1].H[0] = Rs1.B[2] s* Rs2.B[3];
// Rd.W[1].H[1] = Rs1.B[3] s* Rs2.B[2];
//
//Instruction syntax:-   SMUL8 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMUL8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMUL8 +
//1010100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMULX8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMULX8 +
//1010101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMUL8 {
        encoding: 0b1010100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMUL16||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// // SMUL16
// R[d_H] = Rs1.H[1] s* Rs2.H[1];
// R[d_L] = Rs1.H[0] s* Rs2.H[0];
// // SMULX16
// R[d_H] = Rs1.H[1] s* Rs2.H[0];
// R[d_L] = Rs1.H[0] s* Rs2.H[1];
//
//* RV64:
//
// // SMUL16
// Rd.W[1] = Rs1.H[1] s* Rs2.H[1];
// Rd.W[0] = Rs1.H[0] s* Rs2.H[0];   
// // SMULX16
// Rd.W[1] = Rs1.H[1] s* Rs2.H[0];
// Rd.W[0] = Rs1.H[0] s* Rs2.H[1];
//
//Instruction syntax:-   SMUL16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMUL16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMUL16 +
//1010000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMULX16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMULX16 +
//1010001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SMUL16 {
        encoding: 0b1010000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRA||
//--------------
//Instruction description:-
// This instruction right-shifts the content of Rs1 arithmetically. The shifted out bits are filled with the sign-bit and the shift amount is specified by the low-order 5-bits (RV32) or 6-bits (RV64) of the Rs2 register. For the rounding operation, a value of 1 is added to the most significant discarded bit of the data to calculate the final result. And the result is written to Rd.
//
//Instruction operation:-
//
//
//* RV32:
//
// sa = Rs2[4:0];
// if (sa != 0) {
//   res[31:-1] = SE33(Rs1[31:(sa-1)]) + 1;
//   Rd = res[31:0];
// } else {
//   Rd = Rs1;
// }
//
//* RV64:
//
// sa = Rs2[5:0];
// if (sa != 0) {
//   res[63:-1] = SE65(Rs1[63:(sa-1)]) + 1;
//   Rd = res[63:0];
// } else {
//   Rd = Rs1;
// }
//
//Instruction syntax:-   SRA.u Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA.u +
//0010010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SRA {
        encoding: 0b0010010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRAI||
//--------------
//Instruction description:-
// This instruction right-shifts the content of Rs1 arithmetically. The shifted out bits are filled with the sign-bit and the shift amount is specified by the imm5u (RV32) or imm6u (RV64) constant . For the rounding operation, a value of 1 is added to the most significant discarded bit of the data to calculate the final result. And the result is written to Rd.
//
//Instruction operation:-
//
//
//* RV32:
//
// sa = imm5u;
// if (sa != 0) {
//   res[31:-1] = SE33(Rs1[31:(sa-1)]) + 1;
//   Rd = res[31:0];
// } else {
//   Rd = Rs1;
// }
//
//* RV64:
//
// sa = imm6u;
// if (sa != 0) {
//   res[63:-1] = SE65(Rs1[63:(sa-1)]) + 1;
//   Rd = res[63:0];
// } else {
//   Rd = Rs1;
// }
//
//Instruction syntax:-   SRAI.u Rd, Rs1, imm5u (RV32)
//Instruction formate:-
//[.text-center]
//*RV32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI.u +
//1101010 |imm5u |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*RV64*
//
//[cols="6*^.^"]
//|===
//l|31    26 l|25    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI.u +
//110101 |imm6u |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SRAI {
        encoding: 0b1101010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRA8||
//--------------
//Instruction description:-
// The 8-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the data elements. The shift amount is specified by the low-order 3-bits of the value in the Rs2 register. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 8-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = Rs2[2:0];
// if (sa != 0) {
//   if (�.u� form) { // SRA8.u
//     res[7:-1] = SE9(Rs1.B[x][7:sa-1]) + 1;
//     Rd.B[x] = res[7:0];
//   } else { // SRA8
//     Rd.B[x] = SE8(Rd.B[x][7:sa])
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SRA8 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SRA8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA8 +
//0101100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRA8.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA8.u +
//0110100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRA8 {
        encoding: 0b0101100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRAI8||
//--------------
//Instruction description:-
// The 8-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the data elements. The shift amount is specified by the imm3u constant. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 8-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm3u;
// if (sa != 0) {
//   if ('.u' form) { // SRAI8.u
//     res[7:-1] = SE9(Rs1.B[x][7:sa-1]) + 1;
//     Rd.B[x] = res[7:0];
//   } else { // SRAI8
//     Rd.B[x] = SE8(Rd.B[x][7:sa])
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SRAI8 Rd, Rs1, imm3u
//Instruction formate:-
//[.text-center]
//*SRAI8*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI8 +
//0111100 |00 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRAI8.u*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI8.u +
//0111100 |01 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRAI8 {
        encoding: 0b0111100 :: rs2[4:0] :: rs1[4:0] :: 0b00 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRA16||
//--------------
//Instruction description:-
// The 16-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the data elements. The shift amount is specified by the low-order 4-bits of the value in the Rs2 register. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = Rs2[3:0];
// if (sa != 0) {
//   if (�.u� form) { // SRA16.u
//     res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
//     Rd.H[x] = res[15:0];
//   } else { // SRA16
//     Rd.H[x] = SE16(Rs1.H[x][15:sa])
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SRA16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SRA16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA16 +
//0101000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRA16.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA16.u +
//0110000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRA16 {
        encoding: 0b0101000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRAI16||
//--------------
//Instruction description:-
// The 16-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the 16-bit data elements. The shift amount is specified by the imm4u constant. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 16-bit data to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm4u;
// if (sa != 0) {
//   if (�.u� form) { // SRAI16.u
//     res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
//     Rd.H[x] = res[15:0];
//   } else { // SRAI16
//     Rd.H[x] = SE16(Rs1.H[x][15:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SRAI16 Rd, Rs1, imm4u
//Instruction formate:-
//[.text-center]
//*SRAI16*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI16 +
//0111000 |0 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRAI16.u*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI16.u +
//0111000 |1 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRAI16 {
        encoding: 0b0111000 :: rs2[4:0] :: rs1[4:0] :: 0b0 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRL8||
//--------------
//Instruction description:-
// The 8-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the low-order 3-bits of the value in the Rs2 register. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 8-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = Rs2[2:0];
// if (sa != 0) {
//   if (�.u� form) { // SRL8.u
//     res[8:0] = ZE9(Rs1.B[x][7:sa-1]) + 1;
//     Rd.B[x] = res[8:1];
//   } else { // SRL8
//     Rd.B[x] = ZE8(Rs1.B[x][7:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SRL8 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SRL8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRL8 +
//0101101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRL8.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRL8.u +
//0110101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRL8 {
        encoding: 0b0101101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRLI8||
//--------------
//Instruction description:-
// The 8-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the imm3u constant. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 8-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm3u;
// if (sa != 0) {
//   if (�.u� form) { // SRLI8.u
//     res[8:0] = ZE9(Rs1.B[x][7:sa-1]) + 1;
//     Rd.B[x] = res[8:1];
//   } else { // SRLI8
//     Rd.B[x] = ZE8(Rs1.B[x][7:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SRLI8 Rd, Rs1, imm3u
//Instruction formate:-
//[.text-center]
//*SRLI8*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRLI8 +
//0111101 |00 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRLI8.u*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRLI8.u +
//0111101 |01 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRLI8 {
        encoding: 0b0111101 :: rs2[4:0] :: rs1[4:0] :: 0b00 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRL16||
//--------------
//Instruction description:-
// The 16-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the low-order 4-bits of the value in the Rs2 register. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = Rs2[3:0];
// if (sa != 0) {
//   if ('.u' form) { // SRL16.u
//     res[16:0] = ZE17(Rs1.H[x][15:sa-1]) + 1;
//     Rd.H[x] = res[16:1];
//   } else { // SRL16
//     Rd.H[x] = ZE16(Rs1.H[x][15:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SRL16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SRL16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRL16 +
//0101001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRL16.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRL16.u +
//0110001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRL16 {
        encoding: 0b0101001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRLI16||
//--------------
//Instruction description:-
// The 16-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the imm4u constant. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm4u;
// if (sa != 0) {
//   if (�.u� form) { // SRLI16.u
//     res[16:0] = ZE17(Rs1.H[x][15:sa-1]) + 1;
//     Rd.H[x] = res[16:1];
//   } else { // SRLI16
//     Rd.H[x] = ZE16(Rs1.H[x][15:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SRLI16 Rd, Rs1, imm4u
//Instruction formate:-
//[.text-center]
//*SRLI16*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRLI16 +
//0111001 |0 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRLI16.u*
//
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRLI16.u +
//0111001 |1 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SRLI16 {
        encoding: 0b0111001 :: rs2[4:0] :: rs1[4:0] :: 0b0 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||STAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit integer element in [31:16] of 32-bit chunks in Rs1 with the 16-bit integer element in [31:16] of 32-bit chunks in Rs2, and writes the result to [31:16] of 32-bit chunks in Rd; at the same time, it subtracts the 16-bit integer element in [15:0] of 32-bit chunks in Rs2 from the 16-bit integer element in [15:0] of 32-bit chunks, and writes the result to [15:0] of 32-bit chunks in Rd.
//
//For this instruction, any potential overflow bit(s) during the computation are discarded and ignored.
//
//Instruction operation:-
//
//
// Rd.W[x].H[1] = Rs1.W[x].H[1] + Rs2.W[x].H[1]; // overflow discarded
// Rd.W[x].H[0] = Rs1.W[x].H[0] � Rs2.W[x].H[0]; // overflow discarded
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   STAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|STAS16 +
//1111010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    STAS16 {
        encoding: 0b1111010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||STSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit integer element in [31:16] of 32-bit chunks in Rs2 from the 16-bit integer element in [31:16] of 32-bit chunks in Rs1, and writes the result to [31:16] of 32-bit chunks in Rd; at the same time, it adds the 16-bit integer element in [15:0] of 32-bit chunks in Rs2 with the 16-bit integer element in [15:0] of 32-bit chunks in Rs1, and writes the result to [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// Rd.W[x].H[1] = Rs1.W[x].H[1] - Rs2.W[x].H[1];
// Rd.W[x].H[0] = Rs1.W[x].H[0] + Rs2.W[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   STSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|STSA16 +
//1111011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    STSA16 {
        encoding: 0b1111011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SUB8||
//--------------
//Instruction description:-
// This instruction subtracts the 8-bit integer elements in Rs2 from the 8-bit integer elements in Rs1, and then writes the result to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = Rs1.B[x] - Rs2.B[x];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   SUB8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SUB8 +
//0100101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SUB8 {
        encoding: 0b0100101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SUB16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit integer elements in Rs2 from the 16-bit integer elements in Rs1, and then writes the result to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = Rs1.H[x] - Rs2.H[x];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SUB16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SUB16 +
//0100001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SUB16 {
        encoding: 0b0100001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SUB64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// R[t_H].R[t_L] = R[a_H].R[a_L] - R[b_H].R[b_L];
//
//
//Instruction syntax:-   SUB64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SUB64 +
//1100001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SUB64 {
        encoding: 0b1100001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SUNPKD8xy||
//--------------
//Instruction description:-
//
//
//For the �SUNPKD8(__x__)(__y__)� instruction, it unpacks byte _x_ and byte _y_ of 32-bit chunks in Rs1 into two 16-bit signed 
//halfwords and writes the results to the top part and the bottom part of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// Rd.W[m].H[1] = SE16(Rs1.W[m].B[x])
// Rd.W[m].H[0] = SE16(Rs1.W[m].B[y])
// // SUNPKD810, x=1,y=0
// // SUNPKD820, x=2,y=0
// // SUNPKD830, x=3,y=0
// // SUNPKD831, x=3,y=1
// // SUNPKD832, x=3,y=2
// for RV32: m=0,
// for RV64: m=1..0
//
//Instruction syntax:-   SUNPKD8xy Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |SUNPKD8**[.underline]#xy#** +
//*code[4:0]* |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[cols="2*^.^",options="header",]
//|===
//|*[.underline]#xy#* |*[.underline]#code[4:0]#*
//|10 |01000
//|20 |01001
//|30 |01010
//|31 |01011
//|32 |10011
//
    SUNPKD8xy {
        encoding: 0b1010110 :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SWAP8||
//--------------
//Instruction description:-
// This instruction swaps the bytes within each halfword of Rs1 and writes the result to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = CONCAT(Rs1.H[x].B[0],Rs1.H[x].B[1]);
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   SWAP8 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |SWAP8 +
//11000 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    SWAP8 {
        encoding: 0b1010110 :: rs1[4:0] :: 0b11000 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SWAP16||
//--------------
//Instruction description:-
// This instruction swaps the 16-bit halfwords within each word of Rs1 and writes the result to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = CONCAT(Rs1.W[x].H[0],Rs1.W[x].H[1]);
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   SWAP16 Rd, Rs1 # pseudo mnemonic
//Instruction formate:-
//None
    SWAP16 {
        encoding: 0b :: rs1[4:0] :: 0b :: rd[4:0] :: 0b;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCLIP8||
//--------------
//Instruction description:-
// This instruction limits the 8-bit signed elements stored in Rs1 to an unsigned integer range between 2^imm3u^-1 and 0, and writes the limited results to Rd. For example, if imm3u is 3, the 8-bit input values should be saturated between 7 and 0. If saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
//  src = Rs1.H[x];
//  if (src s> (2^imm3u)-1) {
//    src = (2^imm3u)-1;
//    OV = 1;
//  } else if (src s< 0) {
//    src = 0;
//    OV = 1;
//  }
//  Rd.H[x] = src;
//  for RV32: x=3..0,
//  for RV64: x=7..0
//
//Instruction syntax:-   UCLIP8 Rd, Rs1, imm3u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24    23 l|22    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCLIP8 +
//1000110 |10 |imm3u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCLIP8 {
        encoding: 0b1000110 :: rs2[4:0] :: rs1[4:0] :: 0b10 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCLIP16||
//--------------
//Instruction description:-
// This instruction limits the 16-bit signed elements stored in Rs1 to an unsigned integer range between 2^imm4u^-1 and 0, and writes the limited results to Rd. For example, if imm4u is 3, the 16-bit input values should be saturated between 7 and 0. If saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.H[x];
// if (src s> (2^imm4u)-1) {
//   src = (2^imm4u)-1;
//   OV = 1;
// } else if (src s< 0) {
//   src = 0;
//   OV = 1;
// }
// Rd.H[x] = src;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UCLIP16 Rd, Rs1, imm4u
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    25 l|24 l|23    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCLIP16 +
//1000010 |1 |imm4u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCLIP16 {
        encoding: 0b1000010 :: rs2[4:0] :: rs1[4:0] :: 0b1 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCLIP32||
//--------------
//Instruction description:-
// This instruction limits the 32-bit signed integer elements stored in Rs1 to an unsigned integer range between 2^imm5u^-1 and 0, and writes the limited results to Rd. For example, if imm5u is 3, the 32-bit input values should be saturated between 7 and 0. If saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// src = Rs1.W[x];
// if (src s> (2^imm5u)-1) {
//   src = (2^imm5u)-1;
//   OV = 1;
// } else if (src s< 0) {
//   src = 0;
//   OV = 1;
// }
// Rd.W[x] = src
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   UCLIP32 Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCLIP32 +
//1111010 |imm5u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCLIP32 {
        encoding: 0b1111010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCMPLE8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit unsigned integer elements in Rs1 with the 8-bit unsigned integer elements in Rs2 to see if the one in Rs1 is less than or equal to the one in Rs2. If it is true, the result is 0xFF; otherwise, the result is 0x0. The element comparison results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] u<= Rs2.B[x])? 0xff : 0x0;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   UCMPLE8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCMPLE8 +
//0011111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCMPLE8 {
        encoding: 0b0011111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCMPLE16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit unsigned integer elements in Rs1 with the 16-bit unsigned integer elements in Rs2 to see if the one in Rs1 is less than or equal to the one in Rs2. If it is true, the result is 0xFFFF; otherwise, the result is 0x0. The element comparison results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] u<= Rs2.H[x])? 0xffff : 0x0;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UCMPLE16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCMPLE16 +
//0011110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCMPLE16 {
        encoding: 0b0011110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCMPLT8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit unsigned integer elements in Rs1 with the 8-bit unsigned integer elements in Rs2 to see if the one in Rs1 is less than the one in Rs2. If it is true, the result is 0xFF; otherwise, the result is 0x0. The element comparison results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] u< Rs2.B[x])? 0xff : 0x0;
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   UCMPLT8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCMPLT8 +
//0010111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCMPLT8 {
        encoding: 0b0010111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UCMPLT16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit unsigned integer elements in Rs1 with the 16-bit unsigned integer elements in Rs2 to see if the one in Rs1 is less than the one in Rs2. If it is true, the result is 0xFFFF; otherwise, the result is 0x0. The element comparison results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] u< Rs2.H[x])? 0xffff : 0x0;
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UCMPLT16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UCMPLT16 +
//0010110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UCMPLT16 {
        encoding: 0b0010110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKADD8||
//--------------
//Instruction description:-
// This instruction adds the 8-bit unsigned integer elements in Rs1 with the 8-bit unsigned integer elements in Rs2. If any of the results exceed the 8-bit unsigned number range (0 {le} RES {le} 2^8^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = ZE9(Rs1.B[x]) + ZE9(Rs2.B[x]);
// if (res[x] u> (2^8)-1) {
//   res[x] = (2^8)-1;
//   OV = 1;
// }
// Rd.B[x] = res[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   UKADD8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKADD8 +
//0011100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UKADD8 {
        encoding: 0b0011100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKADD16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit unsigned integer elements in Rs1 with the 16-bit unsigned integer elements in Rs2. If any of the results exceed the 16-bit unsigned number range (0 {le} RES {le} 2^16^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = ZE17(Rs1.H[x]) + ZE17(Rs2.H[x]);
// if (res[x] u> (2^16)-1) {
//   res[x] = (2^16)-1;
//   OV = 1;
// }
// Rd.H[x] = res[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UKADD16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKADD16 +
//0011000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UKADD16 {
        encoding: 0b0011000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKADD64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = ZE65(R[a_H].R[a_L]) + ZE65(R[b_H].R[b_L]);
// if (res65 u> (2^64)-1) {
//   res65 = (2^64)-1; OV = 1;
// }
// R[d_H].R[d_L] = res65.D[0];
//
//* RV64:
//
// res65 = ZE65(Rs1) + ZE65(Rs2);
// if (res65 u> (2^64)-1) {
//   res65 = (2^64)-1; OV = 1;
// }
// Rd = res65.D[0];
//
//Instruction syntax:-   UKADD64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKADD64 +
//1011000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKADD64 {
        encoding: 0b1011000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKADDH||
//--------------
//Instruction description:-
// The unsigned lower 16-bit content of Rs1 is added with the unsigned lower 16-bit content of Rs2. And the result is saturated to the 16-bit unsigned integer range of [0, 2^16^-1] and then sign-extended and written to Rd. If saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// a17 = ZE17(Rs1.H[0]);
// b17 = ZE17(Rs2.H[0]);
// t17 = a17 + b17;
// if (t17 u> (2^16)-1) {
//   t17 = (2^16)-1;
//   OV = 1;
// }
// Rd = SE32(t17.H[0]); // RV32
// Rd = SE64(t17.H[0]); // RV64
//
//Instruction syntax:-   UKADDH Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKADDH +
//0001010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKADDH {
        encoding: 0b0001010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKADDW||
//--------------
//Instruction description:-
// The unsigned lower 32-bit content of Rs1 is added with the unsigned lower 32-bit content of Rs2. And the result is saturated to the 32-bit unsigned integer range of [0, 2^32^-1] and then sign-extended and written to Rd. If saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// res33 = ZE33(Rs1.W[0]) + ZE33(Rs2.W[0]);
// if (res33 u> (2^32)-1) {
//   res33 = (2^32)-1;
//   OV = 1;
// }
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   UKADDW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKADDW +
//0001000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKADDW {
        encoding: 0b0001000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKCRAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs1 with the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs2; at the same time, it subtracts the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs2 from the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the 16-bit unsigned number range (0 {le} RES {le} 2^16^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for addition and [15:0] of 32-bit chunks in Rd for subtraction.
//
//Instruction operation:-
//
//
// res1[x] = ZE17(Rs1.W[x].H[1]) + ZE17(Rs2.W[x].H[0]);
// res2[x] = ZE17(Rs1.W[x].H[0]) � ZE17(Rs2.W[x].H[1]);
// if (res1[x] u> (2^16)-1) {
//   res1[x] = (2^16)-1;
//   OV = 1;
// }
// if (res2[x] s< 0) {
//   res2[x] = 0;
//   OV = 1;
// }
// Rd.W[x].H[1] = res1[x].H[0];
// Rd.W[x].H[0] = res2[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   UKCRAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKCRAS16 +
//0011010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UKCRAS16 {
        encoding: 0b0011010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKCRSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs2 from the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs1; at the same time, it adds the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs2 with the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the 16-bit unsigned number range (0 {le} RES {le} 2^16^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for subtraction and [15:0] of 32-bit chunks in Rd for addition.
//
//Instruction operation:-
//
//
// res1[x] = ZE17(Rs1.W[x].H[1]) - ZE17(Rs2.W[x].H[0]);
// res2[x] = ZE17(Rs1.W[x].H[0]) + ZE17(Rs2.W[x].H[1]);
// if (res1[x] s< 0) {
//   res1[x] = 0;
//   OV = 1;
// } else if (res2[x] u> (2^16)-1) {
//   res2[x] = (2^16)-1;
//   OV = 1;
// }
// Rd.W[x].H[1] = res1[x].H[0];
// Rd.W[x].H[0] = res2[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   UKCRSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKCRSA16 +
//0011011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UKCRSA16 {
        encoding: 0b0011011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKMAR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// mul65 = ZE65(Rs1 u* Rs2);
// top65 = ZE65(R[t_H].R[t_L]);
// res65 = top65 + mul65;
// if (res65 u> (2^64)-1) {
//   res65 = (2^64)-1;
//   OV = 1;
// }
// R[t_H].R[t_L] = res65.D[0];
//
//* RV64:
//
// mula66 = ZE66(Rs1.W[0] u* Rs2.W[0]);
// mulb66 = ZE66(Rs1.W[1] u* Rs2.W[1]);
// res66 = ZE66(Rd) + mula66 + mulb66;
// if (res66 u> (2^64)-1) {
//   res66 = (2^64)-1;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   UKMAR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKMAR64 +
//1011010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKMAR64 {
        encoding: 0b1011010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKMSR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// mul65 = ZE65(Rs1 u* Rs2);
// top65 = ZE65(R[t_H].R[t_L]);
// res65 = top65 - mul65;
// if (res65 s< 0) {
//   res65 = 0;
//   OV = 1;
// }
// R[t_H].R[t_L] = res65.D[0];
//
//* RV64:
//
// mula66 = ZE66(Rs1.W[0] u* Rs2.W[0]);
// mulb66 = ZE66(Rs1.W[1] u* Rs2.W[1]);
// res66 = ZE66(Rd) - mula66 - mulb66;
// if (res66 s< 0) {
//   res66 = 0;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   UKMSR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKMSR64 +
//1011011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKMSR64 {
        encoding: 0b1011011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSTAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs1 with the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs2; at the same time, it subtracts the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs2 from the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the 16-bit unsigned number range (0 {le} RES {le} 2^16^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for addition and [15:0] of 32-bit chunks in Rd for subtraction.
//
//Instruction operation:-
//
//
// res1[x] = ZE17(Rs1.W[x].H[1]) + ZE17(Rs2.W[x].H[1]);
// res2[x] = ZE17(Rs1.W[x].H[0]) � ZE17(Rs2.W[x].H[0]);
// if (res1[x] u> (2^16)-1) {
//   res1[x] = (2^16)-1;
//   OV = 1;
// }
// if (res2[x] s< 0) {
//   res2[x] = 0;
//   OV = 1;
// }
// Rd.W[x].H[1] = res1[x].H[0];
// Rd.W[x].H[0] = res2[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   UKSTAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSTAS16 +
//1110010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKSTAS16 {
        encoding: 0b1110010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSTSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs2 from the 16-bit unsigned integer element in [31:16] of 32-bit chunks in Rs1; at the same time, it adds the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs2 with the 16-bit unsigned integer element in [15:0] of 32-bit chunks in Rs1. If any of the results exceed the 16-bit unsigned number range (0 {le} RES {le} 2^16^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [31:16] of 32-bit chunks in Rd for subtraction and [15:0] of 32-bit chunks in Rd for addition.
//
//Instruction operation:-
//
//
// res1[x] = ZE17(Rs1.W[x].H[1]) - ZE17(Rs2.W[x].H[1]);
// res2[x] = ZE17(Rs1.W[x].H[0]) + ZE17(Rs2.W[x].H[0]);
// if (res1[x] s< 0) {
//   res1[x] = 0;
//   OV = 1;
// } else if (res2[x] u> (2^16)-1) {
//   res2[x] = (2^16)-1;
//   OV = 1;
// }
// Rd.W[x].H[1] = res1[x].H[0];
// Rd.W[x].H[0] = res2[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   UKSTSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSTSA16 +
//1110011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKSTSA16 {
        encoding: 0b1110011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSUB8||
//--------------
//Instruction description:-
// This instruction subtracts the 8-bit unsigned integer elements in Rs2 from the 8-bit unsigned integer elements in Rs1. If any of the results exceed the 8-bit unsigned number range (0 {le} RES {le} 2^8^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = ZE9(Rs1.B[x]) - ZE9(Rs2.B[x]);
// if (res[x] s< 0) {
//   res[x] = 0;
//   OV = 1;
// }
// Rd.B[x] = res[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   UKSUB8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSUB8 +
//0011101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UKSUB8 {
        encoding: 0b0011101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSUB16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit unsigned integer elements in Rs2 from the 16-bit unsigned integer elements in Rs1. If any of the results exceed the 16-bit unsigned number range (0 {le} RES {le} 2^16^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = ZE17(Rs1.H[x]) - ZE17(Rs2.H[x]);
// if (res[x] s< 0) {
//   res[x] = 0;
//   OV = 1;
// }
// Rd.H[x] = res[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UKSUB16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSUB16 +
//0011001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UKSUB16 {
        encoding: 0b0011001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSUB64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// t_L = CONCAT(Rd(4,1),1'b0); t_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = ZE65(R[a_H].R[a_L]) - ZE65(R[b_H].R[b_L]);
// if (res65 s< 0) {
//   res65 = 0; OV = 1;
// }
// R[t_H].R[t_L] = res65.D[0];
//
//* RV64
//
// result = Rs1 � Rs2;
// if (result s< 0) {
//   result = 0; OV = 1;
// }
// Rd = result;
//
//Instruction syntax:-   UKSUB64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSUB64 +
//1011001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKSUB64 {
        encoding: 0b1011001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSUBH||
//--------------
//Instruction description:-
// The unsigned lower 16-bit content of Rs2 is subtracted from the unsigned lower 16-bit content of Rs1. And the result is saturated to the 16-bit unsigned integer range of [0, 2^16^-1] and then sign-extended and written to Rd. If saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// a17 = ZE17(Rs1.H[0]);
// b17 = ZE17(Rs2.H[0]);
// t17 = a17 - b17;
// if (t17 s> (2^16)-1) {
//   t17 = (2^16)-1;
//   OV = 1;
// }
// else if (t17 s< 0) {
//   t17 = 0;
//   OV = 1;
// }
// Rd = SE32(t17.H[0]); // RV32
// Rd = SE64(t17.H[0]); // RV64
//
//Instruction syntax:-   UKSUBH Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSUBH +
//0001011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKSUBH {
        encoding: 0b0001011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSUBW||
//--------------
//Instruction description:-
// The unsigned lower 32-bit content of Rs2 is subtracted from the unsigned lower 32-bit content of Rs1. And the result is saturated to the 32-bit unsigned integer range of [0, 2^32^-1] and then sign-extended and written to Rd. If saturation happens, this instruction sets the OV flag.
//
//Instruction operation:-
//
//
// aop33 = ZE33(Rs1.W[0]);
// bop33 = ZE33(Rs2.W[0]);
// res33 = aop33 � bop33;
// if (res33 s< 0) {
//   res33 = 0;
//   OV = 1;
// }
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   UKSUBW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSUBW +
//0001001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UKSUBW {
        encoding: 0b0001001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMAR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// R[d_H].R[d_L] = R[d_H].R[d_L] + (Rs1 u* Rs2);
//
//* RV64:
//
// Rd = Rd + (Rs1.W[0] u* Rs2.W[0]) + (Rs1.W[1] u* Rs2.W[1]);
//
//Instruction syntax:-   UMAR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMAR64 +
//1010010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UMAR64 {
        encoding: 0b1010010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMAQA||
//--------------
//Instruction description:-
//
//
//This instruction multiplies the four unsigned 8-bit elements of 32-bit chunks of Rs1 with the four unsigned 8-bit elements of 32-bit chunks of Rs2 and then adds the four results together with the unsigned content of the corresponding 32-bit chunks of Rd. The final results are written back to the corresponding 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res[x] = Rd.W[x] + (Rs1.W[x].B[3] u* Rs2.W[x].B[3]) +
//          (Rs1.W[x].B[2] u* Rs2.W[x].B[2]) + (Rs1.W[x].B[1] u* Rs2.W[x].B[1]) +
//          (Rs1.W[x].B[0] u* Rs2.W[x].B[0]);
// Rd.W[x] = res[x];
// for RV32: x=0,
// for RV64: x=1..0
//
//Instruction syntax:-   UMAQA Rd, Rs1, Rs2
//Instruction formate:-
//*UMAQA*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMAQA +
//1100110 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMAQA {
        encoding: 0b1100110 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMAX8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit unsigned integer elements in Rs1 with the corresponding 8-bit unsigned integer elements in Rs2 and selects the numbers that is greater than the other one. The two selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] >u Rs2.B[x])? Rs1.B[x] : Rs2.B[x];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   UMAX8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMAX8 +
//1001101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMAX8 {
        encoding: 0b1001101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMAX16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit unsigned integer elements in Rs1 with the corresponding 16-bit unsigned integer elements in Rs2 and selects the numbers that is greater than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] >u Rs2.H[x])? Rs1.H[x] : Rs2.H[x];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UMAX16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMAX16 +
//1001001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMAX16 {
        encoding: 0b1001001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMIN8||
//--------------
//Instruction description:-
// This instruction compares the 8-bit unsigned integer elements in Rs1 with the 8-bit unsigned integer elements in Rs2 and selects the numbers that is less than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.B[x] = (Rs1.B[x] <u Rs2.B[x])? Rs1.B[x] : Rs2.B[x];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   UMIN8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMIN8 +
//1001100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMIN8 {
        encoding: 0b1001100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMIN16||
//--------------
//Instruction description:-
// This instruction compares the 16-bit unsigned integer elements in Rs1 with the 16-bit unsigned integer elements in Rs2 and selects the numbers that is less than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.H[x] = (Rs1.H[x] <u Rs2.H[x])? Rs1.H[x] : Rs2.H[x];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   UMIN16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMIN16 +
//1001000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMIN16 {
        encoding: 0b1001000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMSR64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// R[d_H].R[d_L] = R[d_H].R[d_L] - (Rs1 u* Rs2);
//
//* RV64:
//
// Rd = Rd - (Rs1.W[0] u* Rs2.W[0]) - (Rs1.W[1] u* Rs2.W[1]);
//
//Instruction syntax:-   UMSR64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMSR64 +
//1010011 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    UMSR64 {
        encoding: 0b1010011 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMUL8||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// // UMUL8
// R[d_L].H[0] = Rs1.B[0] u* Rs2.B[0];
// R[d_L].H[1] = Rs1.B[1] u* Rs2.B[1];
// R[d_H].H[0] = Rs1.B[2] u* Rs2.B[2];
// R[d_H].H[1] = Rs1.B[3] u* Rs2.B[3];
// // UMULX8
// R[d_L].H[0] = Rs1.B[0] u* Rs2.B[1];
// R[d_L].H[1] = Rs1.B[1] u* Rs2.B[0];
// R[d_H].H[0] = Rs1.B[2] u* Rs2.B[3];
// R[d_H].H[1] = Rs1.B[3] u* Rs2.B[2];
//
//* RV64:
//
// // UMUL8
// Rd.W[0].H[0] = Rs1.B[0] u* Rs2.B[0];
// Rd.W[0].H[1] = Rs1.B[1] u* Rs2.B[1];
// Rd.W[1].H[0] = Rs1.B[2] u* Rs2.B[2];
// Rd.W[1].H[1] = Rs1.B[3] u* Rs2.B[3];
// // UMULX8
// Rd.W[0].H[0] = Rs1.B[0] u* Rs2.B[1];
// Rd.W[0].H[1] = Rs1.B[1] u* Rs2.B[0];
// Rd.W[1].H[0] = Rs1.B[2] u* Rs2.B[3];
// Rd.W[1].H[1] = Rs1.B[3] u* Rs2.B[2];
//
//Instruction syntax:-   UMUL8 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*UMUL8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMUL8 +
//1011100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*UMULX8*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMULX8 +
//1011101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMUL8 {
        encoding: 0b1011100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMUL16||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// // UMUL16
// R[d_H] = Rs1.H[1] u* Rs2.H[1];
// R[d_L] = Rs1.H[0] u* Rs2.H[0]; 
// // UMULX16
// R[d_H] = Rs1.H[1] u* Rs2.H[0];
// R[d_L] = Rs1.H[0] u* Rs2.H[1];
//
//* RV64:
//
// // UMUL16
// Rd.W[1] = Rs1.H[1] u* Rs2.H[1];
// Rd.W[0] = Rs1.H[0] u* Rs2.H[0];
// // UMULX16
// Rd.W[1] = Rs1.H[1] u* Rs2.H[0];
// Rd.W[0] = Rs1.H[0] u* Rs2.H[1];
//
//Instruction syntax:-   UMUL16 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*UMUL16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMUL16 +
//1011000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*UMULX16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMULX16 +
//1011001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    UMUL16 {
        encoding: 0b1011000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URADD8||
//--------------
//Instruction description:-
// This instruction adds the 8-bit unsigned integer elements in Rs1 with
//the 8-bit unsigned integer elements in Rs2. The 9-bit results are first
//right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res9[x] = (ZE9(Rs1.B[x]) + ZE9(Rs2.B[x])) u>> 1;
// Rd.B[x] = res9[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   URADD8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URADD8 +
//0010100 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    URADD8 {
        encoding: 0b0010100 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URADD16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit unsigned integer elements in Rs1
//with the 16-bit unsigned integer elements in Rs2. The 17-bit results are first
//right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res17[x] = (ZE17(Rs1.H[x]) + ZE17(Rs2.H[x])) u>> 1;
// Rd.H[x] = res17[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   URADD16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URADD16 +
//0010000 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    URADD16 {
        encoding: 0b0010000 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URADD64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = (ZE65(R[a_H].R[a_L]) + ZE65(R[b_H].R[b_L])) u>> 1;
// R[d_H].R[d_L] = res65.D[0];
//
//* RV64:
//
// res65 = (ZE65(Rs1) + ZE65(Rs2)) u>> 1;
// Rd = res65.D[0];
//
//Instruction syntax:-   URADD64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URADD64 +
//1010000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    URADD64 {
        encoding: 0b1010000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URADDW||
//--------------
//Instruction description:-
// This instruction adds the first 32-bit unsigned integer in Rs1 with
//the first 32-bit unsigned integer in Rs2. The 33-bit result is first right-shifted
//by 1 bit and then sign-extended and written to Rd.
//
//Instruction operation:-
//
//
// res33 = (ZE33(Rs1.W[0]) + ZE33(Rs2.W[0])) u>> 1;
// 
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   URADDW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URADDW +
//0011000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    URADDW {
        encoding: 0b0011000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URCRAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit unsigned integer in [31:16] of 32-bit
//chunks in Rs1 with the 16-bit unsigned integer in [15:0] of 32-bit chunks in Rs2,
//and subtracts the 16-bit unsigned integer in [31:16] of 32-bit chunks in Rs2 from
//the 16-bit unsigned integer in [15:0] of 32-bit chunks in Rs1. The 17-bit element
//results are first right-shifted by 1 bit and then written to [31:16] of 32-bit
//chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_add17[x] = (ZE17(Rs1.W[x].H[1]) + ZE17(Rs2.W[x].H[0])) u>> 1;
// res_sub17[x] = (ZE17(Rs1.W[x].H[0]) � ZE17(Rs2.W[x].H[1])) u>> 1;
// Rd.W[x].H[1] = res_add17[x].H[0];
// Rd.W[x].H[0] = res_sub17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   URCRAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URCRAS16 +
//0010010 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    URCRAS16 {
        encoding: 0b0010010 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URCRSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit unsigned integer in [15:0]
//of 32-bit chunks in Rs2 from the 16-bit unsigned integer in [31:16] of 32-bit
//chunks in Rs1, and adds the 16-bit unsigned integer in [15:0] of 32-bit chunks
//in Rs1 with the 16-bit unsigned integer in [31:16] of 32-bit chunks in Rs2. The
//two 17-bit results are first right-shifted by 1 bit and then written to [31:16]
//of 32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_sub17[x] = (ZE17(Rs1.W[x].H[1]) - ZE17(Rs2.W[x].H[0])) u>> 1;
// res_add17[x] = (ZE17(Rs1.W[x].H[0]) + ZE17(Rs2.W[x].H[1])) u>> 1;
// Rd.W[x].H[1] = res_sub17[x].H[0];
// Rd.W[x].H[0] = res_add17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   URCRSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URCRSA16 +
//0010011 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    URCRSA16 {
        encoding: 0b0010011 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSTAS16||
//--------------
//Instruction description:-
// This instruction adds the 16-bit unsigned integer in [31:16] of
//32-bit chunks in Rs1 with the 16-bit unsigned integer in [31:16] of 32-bit chunks
//in Rs2, and subtracts the 16-bit unsigned integer in [15:0] of 32-bit chunks in
//Rs2 from the 16-bit unsigned integer in [15:0] of 32-bit chunks in Rs1. The 17-bit
//element results are first right-shifted by 1 bit and then written to [31:16] of
//32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_add17[x] = (ZE17(Rs1.W[x].H[1]) + ZE17(Rs2.W[x].H[1])) u>> 1;
// res_sub17[x] = (ZE17(Rs1.W[x].H[0]) � ZE17(Rs2.W[x].H[0])) u>> 1;
// Rd.W[x].H[1] = res_add17[x].H[0];
// Rd.W[x].H[0] = res_sub17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   URSTAS16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSTAS16 +
//1101010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URSTAS16 {
        encoding: 0b1101010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URCRSA16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit unsigned integer in [31:16]
//of 32-bit chunks in Rs2 from the 16-bit unsigned integer in [31:16] of 32-bit
//chunks in Rs1, and adds the 16-bit unsigned integer in [15:0] of 32-bit chunks
//in Rs1 with the 16-bit unsigned integer in [15:0] of 32-bit chunks in Rs2.
//The two 17-bit results are first right-shifted by 1 bit and then written to [31:16]
//of 32-bit chunks in Rd and [15:0] of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// res_sub17[x] = (ZE17(Rs1.W[x].H[1]) - ZE17(Rs2.W[x].H[1])) u>> 1;
// res_add17[x] = (ZE17(Rs1.W[x].H[0]) + ZE17(Rs2.W[x].H[0])) u>> 1;
// Rd.W[x].H[1] = res_sub17[x].H[0];
// Rd.W[x].H[0] = res_add17[x].H[0];
// for RV32, x=0
// for RV64, x=1..0
//
//Instruction syntax:-   URCRSA16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSTSA16 +
//1101011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URCRSA16 {
        encoding: 0b1101011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSUB8||
//--------------
//Instruction description:-
// This instruction subtracts the 8-bit unsigned integer elements in
//Rs2 from the 8-bit unsigned integer elements in Rs1. The 9-bit results are first
//right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res9[x] = (ZE9(Rs1.B[x]) - ZE9(Rs2.B[x])) u>> 1;
// Rd.B[x] = res9[x].B[0];
// for RV32: x=3..0,
// for RV64: x=7..0
//
//Instruction syntax:-   URSUB8 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSUB8 +
//0010101 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    URSUB8 {
        encoding: 0b0010101 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSUB16||
//--------------
//Instruction description:-
// This instruction subtracts the 16-bit unsigned integer elements in
//Rs2 from the 16-bit unsigned integer elements in Rs1. The 17-bit results are first
//right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res17[x] = (ZE17(Rs1.H[x]) - ZE17(Rs2.H[x])) u>> 1;
// Rd.H[x] = res17[x].H[0];
// for RV32: x=1..0,
// for RV64: x=3..0
//
//Instruction syntax:-   URSUB16 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSUB16 +
//0010001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    URSUB16 {
        encoding: 0b0010001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSUB64||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// d_L = CONCAT(Rd(4,1),1'b0); d_H = CONCAT(Rd(4,1),1'b1);
// a_L = CONCAT(Rs1(4,1),1'b0); a_H = CONCAT(Rs1(4,1),1'b1);
// b_L = CONCAT(Rs2(4,1),1'b0); b_H = CONCAT(Rs2(4,1),1'b1);
// res65 = (ZE65(R[a_H].R[a_L]) - ZE65(R[b_H].R[b_L])) u>> 1;
// R[d_H].R[d_L] = res65.D[0];
//
//
//* RV64:
//
// res65 = (ZE65(Rs1) - ZE65(Rs2)) u>> 1;
// Rd = res65.D[0];
//
//Instruction syntax:-   URSUB64 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSUB64 +
//1010001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    URSUB64 {
        encoding: 0b1010001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSUBW||
//--------------
//Instruction description:-
// This instruction subtracts the first 32-bit unsigned integer in Rs2
//from the first 32-bit unsigned integer in Rs1. The 33-bit result is first
//right-shifted by 1 bit and then sign-extended and written to Rd.
//
//Instruction operation:-
//
//
// res33 = (ZE33(Rs1.W[0]) - ZE33(Rs2.W[0])) u>> 1;
//   
// Rd = res33.W[0];       // RV32
// Rd = SE64(res33.W[0]); // RV64
//
//Instruction syntax:-   URSUBW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSUBW +
//0011001 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    URSUBW {
        encoding: 0b0011001 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||WEXTI||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// Idx0 = CONCAT(Rs1(4,1),1'b0); Idx1 = CONCAT(Rs1(4,1),1'b1);
// src[63:0] = Concat(R[Idx1], R[Idx0]);
// LSB = imm5u;
// Rd = src[31+LSB:LSB];
//
//* RV64:
//
// LSB = imm5u;
// ExtractW = Rs1[31+LSB:LSB];
// Rd = SE64(ExtractW)
//
//Instruction syntax:-   WEXTI Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|WEXTI +
//1101111 |imm5u |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    WEXTI {
        encoding: 0b1101111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||WEXT||
//--------------
//Instruction description:-
//NoneInstruction operation:-
//
//
//* RV32:
//
// Idx0 = CONCAT(Rs1(4,1),1'b0); Idx1 = CONCAT(Rs1(4,1),1'b1);
// src[63:0] = CONCAT(R[Idx1], R[Idx0]);
// LSBloc = Rs2[4:0];
// Rd = src[31+LSBloc:LSBloc];
//
//* RV64:
//
// LSBloc = Rs2[4:0];
// ExtractW = Rs1[31+LSBloc:LSBloc];
// Rd = SE64(ExtractW)
//
//Instruction syntax:-   WEXT Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|WEXT +
//1100111 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    WEXT {
        encoding: 0b1100111 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||ZUNPKD8xy||
//--------------
//Instruction description:-
//
//
//For the �ZUNPKD8(__x__)(__y__)� instruction, it unpacks byte _x_ and byte _y_ of 32-bit chunks in Rs1 into two 16-bit unsigned halfwords and writes the results to the top part and the bottom part of 32-bit chunks in Rd.
//
//Instruction operation:-
//
//
// Rd.W[m].H[1] = ZE16(Rs1.W[m].B[x])
// Rd.W[m].H[0] = ZE16(Rs1.W[m].B[y])
// // ZUNPKD810, x=1,y=0
// // ZUNPKD820, x=2,y=0
// // ZUNPKD830, x=3,y=0
// // ZUNPKD831, x=3,y=1
// // ZUNPKD832, x=3,y=2
// for RV32: m=0,
// for RV64: m=1..0
//
//Instruction syntax:-   ZUNPKD8xy Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |ZUNPKD8**[.underline]#xy#** +
//*code[4:0]* |Rs1 |000 |Rd
//|OP-P +
//1110111
//|===
//
//[cols="2*^.^",options="header",]
//|===
//|*[.underline]#xy#* |*[.underline]#code[4:0]#*
//|10 |01100
//|20 |01101
//|30 |01110
//|31 |01111
//|32 |10111
//
    ZUNPKD8xy {
        encoding: 0b1010110 :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||ADD32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit integer elements in Rs1 with the 32-bit integer elements in Rs2, and then writes the 32-bit element results to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = Rs1.W[x] + Rs2.W[x];
// for RV64: x=1..0
//
//Instruction syntax:-   ADD32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ADD32 +
//0100000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    ADD32 {
        encoding: 0b0100000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CRAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit integer element in [63:32] of Rs1 with the 32-bit integer element in [31:0] of Rs2, and writes the result to [63:32] of Rd; at the same time, it subtracts the 32-bit integer element in [63:32] of Rs2 from the 32-bit integer element in [31:0] of Rs1, and writes the result to [31:0] of Rd.
//
//Instruction operation:-
//
//
// Rd.W[1] = Rs1.W[1] + Rs2.W[0];
// Rd.W[0] = Rs1.W[0] � Rs2.W[1];
//
//Instruction syntax:-   CRAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|CRAS32 +
//0100010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    CRAS32 {
        encoding: 0b0100010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||CRSA32||
//--------------
//Instruction description:-
//
//
//This instruction subtracts the 32-bit integer element in [31:0] of Rs2 from the 32-bit integer element in [63:32] of Rs1, and writes the result to [63:32] of Rd; at the same time, it adds the 32-bit integer element in [31:0] of Rs1 with the 32-bit integer element in [63:32] of Rs2, and writes the result to [31:0] of Rd
//
//Instruction operation:-
//
//
// Rd.W[1] = Rs1.W[1] - Rs2.W[0];
// Rd.W[0] = Rs1.W[0] + Rs2.W[1];
//
//Instruction syntax:-   CRSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|CRSA32 +
//0100011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    CRSA32 {
        encoding: 0b0100011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KABS32||
//--------------
//Instruction description:-
// This instruction calculates the absolute value of signed 32-bit integer elements stored in Rs1. The results are written to Rd. This instruction with the minimum negative integer input of 0x80000000 will produce a saturated output of maximum positive integer of 0x7fffffff and the OV flag will be set to 1.
//
//Instruction operation:-
//
//
// if (Rs1.W[x] s>= 0) {
//   res[x] = Rs1.W[x];
// } else {
//   If (Rs1.W[x] == 0x80000000) {
//     res[x] = 0x7fffffff;
//     OV = 1;
//   } else {
//     res[x] = -Rs1.W[x];
//   }
// }
// Rd.W[x] = res[x];
// for RV64: x=1..0
//
//Instruction syntax:-   KABS32 Rd, Rs1
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|ONEOP +
//1010110 |KABS32 +
//10010 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    KABS32 {
        encoding: 0b1010110 :: rs1[4:0] :: 0b10010 :: rd[4:0] :: 0b000;
        args_disass:"{name(rd)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KADD32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit signed integer elements in Rs1 with the 32-bit signed integer elements in Rs2. If any of the results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res33[x] = SE33(Rs1.W[x]) + SE33(Rs2.W[x]);
// if (res33[x] s> (2^31)-1) {
//   res33[x] = (2^31)-1;
//   OV = 1;
// } else if (res33[x] s< -2^31) {
//   res33[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   KADD32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KADD32 +
//0001000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KADD32 {
        encoding: 0b0001000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KCRAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit integer element in [63:32] of Rs1 with the 32-bit integer element in [31:0] of Rs2; at the same time, it subtracts the 32-bit integer element in [63:32] of Rs2 from the 32-bit integer element in [31:0] of Rs1. If any of the results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for addition and [31:0] of Rd for subtraction.
//
//Instruction operation:-
//
//
// res[1] = SE33(Rs1.W[1]) + SE33(Rs2.W[0]);
// res[0] = SE33(Rs1.W[0]) � SE33(Rs2.W[1]);
// if (res[x] s> (2^31)-1) {
//   res[x] = (2^31)-1;
//   OV = 1;
// } else if (res s< -2^31) {
//   res[x] = -2^31;
//   OV = 1;
// }
// Rd.W[1] = res[1].W[0];
// Rd.W[0] = res[0].W[0];
// for RV64, x=1..0
//
//Instruction syntax:-   KCRAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KCRAS32 +
//0001010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KCRAS32 {
        encoding: 0b0001010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KCRSA32||
//--------------
//Instruction description:-
//
//
//This instruction subtracts the 32-bit integer element in [31:0] of Rs2 from the 32-bit integer element in [63:32] of Rs1; at the same time, it adds the 32-bit integer element in [31:0] of Rs1 with the 32-bit integer element in [63:32] of Rs2. If any of the results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for subtraction and [31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res[1] = SE33(Rs1.W[1]) - SE33(Rs2.W[0]);
// res[0] = SE33(Rs1.W[0]) + SE33(Rs2.W[1]);
// if (res[x] s> (2^31)-1) {
//   res[x] = (2^31)-1;
//   OV = 1;
// } else if (res s< -2^31) {
//   res[x] = -2^31;
//   OV = 1;
// }
// Rd.W[1] = res[1].W[0];
// Rd.W[0] = res[0].W[0];
// for RV64, x=1..0
//
//Instruction syntax:-   KCRSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KCRSA32 +
//0001011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KCRSA32 {
        encoding: 0b0001011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KDMxy16||
//--------------
//Instruction description:-
// Multiply the top or bottom 16-bit Q15 content of the 32-bit portions in Rs1 with the top or bottom 16-bit Q15 content of the 32-bit portions in Rs2. The Q30 results are then doubled and saturated into Q31 values. The Q31 values are then written into the 32-bit chunks in Rd. When both the two Q15 inputs are 0x8000, saturation will happen. The result will be saturated to 0x7FFFFFFF and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// // KDMBB16: (x,y,z)=(0,0,0),(2,2,1)
// // KDMBT16: (x,y,z)=(0,1,0),(2,3,1)
// // KDMTT16: (x,y,z)=(1,1,0),(3,3,1)
// aop[z] = Rs1.H[x]; bop[z] = Rs2.H[y];
// If ((0x8000 != aop[z]) || (0x8000 != bop[z])) {
//   Mres32[z] = aop[z] * bop[z];
//   shifted33[z] = SE33(Mres32[z]) << 1;
//   resQ31[z] =  shifted33[z].W[0];
// } else {
//   resQ31[z] = 0x7FFFFFFF;
//   OV = 1;
// }
// Rd.W[z] = resQ31[z];
//
//Instruction syntax:-   KDMxy16 Rd, Rs1, Rs2 (xy = BB, BT, TT)
//Instruction formate:-
//[.text-center]
//*KDMBB16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMBB16 +
//1101101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMBT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMBT16 +
//1110101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMTT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMTT16 +
//1111101 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KDMxy16 {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KDMAxy16||
//--------------
//Instruction description:-
// Multiply the top or bottom 16-bit Q15 content of the 32-bit portions in Rs1 with the top or bottom 16-bit Q15 content of the corresponding 32-bit portions in Rs2. The Q30 results are then doubled and saturated into Q31 values. The Q31 values are then added with the content of the corresponding 32-bit portions of Rd. If the addition results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV flag is set to 1. The results after saturation are written back to Rd.
//
//When both the two Q15 inputs are 0x8000, saturation will happen and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// // KDMABB16: (x,y,z)=(0,0,0),(2,2,1)
// // KDMABT16: (x,y,z)=(0,1,0),(2,3,1)
// // KDMATT16: (x,y,z)=(1,1,0),(3,3,1)
// aop[z] = Rs1.H[x]; bop[z] = Rs2.H[y];
// If ((0x8000 != aop[z]) || (0x8000 != bop[z])) {
//   Mres32[z] = aop[z] * bop[z];
//   shifted33[z] = SE33(Mres32[z]) << 1;
//   resQ31[z] = shifted33[z].W[0];
// } else {
//   resQ31[z] = 0x7FFFFFFF;
//   OV = 1;
// }
// resadd[z] = SE33(Rd.W[z]) + SE33(resQ31[z]);
// if (resadd[z] s> (2^31)-1) {
//   resadd[z] = (2^31)-1;
//   OV = 1;
// } else if (resadd[z] s< -2^31) {
//   resadd[z] = -2^31;
//   OV = 1;
// }
// Rd.W[z] = resadd[z].W[0];
//
//Instruction syntax:-   KDMAxy16 Rd, Rs1, Rs2 (xy = BB, BT, TT)
//Instruction formate:-
//[.text-center]
//*KDMABB16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMABB16 +
//1101100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMABT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMABT16 +
//1110100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KDMATT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KDMATT16 +
//1111100 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KDMAxy16 {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KHMxy16||
//--------------
//Instruction description:-
// Multiply the top or bottom 16-bit Q15 content of the 32-bit portions in Rs1 with the top or bottom 16-bit Q15 content of the 32-bit portion in Rs2. The Q30 results are then right-shifted 15-bits and saturated into Q15 values. The 32-bit Q15 values are then written into the 32-bit chunks in Rd. When both the two Q15 inputs are 0x8000, saturation will happen. The result will be saturated to 0x7FFF and the overflow flag OV will be set.
//
//Instruction operation:-
//
//
// // KHMBB16: (x,y,z)=(0,0,0),(2,2,1)
// // KHMBT16: (x,y,z)=(0,1,0),(2,3,1)
// // KHMTT16: (x,y,z)=(1,1,0),(3,3,1)
// aop = Rs1.H[x]; bop = Rs2.H[y];
// If ((0x8000 != aop) || (0x8000 != bop)) {
//   Mresult[31:0] = aop * bop;
//   res[15:0] = Mresult[30:15];
// } else {
//   res[15:0] = 0x7FFF;
//   OV = 1;
// }
// Rd.W[z] = SE32(res[15:0]);
//
//Instruction syntax:-   KHMxy16 Rd, Rs1, Rs2 (xy = BB, BT, TT)
//Instruction formate:-
//[.text-center]
//*KHMBB16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMBB16 +
//1101110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KHMBT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMBT16 +
//1110110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KHMTT16*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KHMTT16 +
//1111110 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    KHMxy16 {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMABB32||
//--------------
//Instruction description:-
//
//
//For the �KMABB32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element in Rs1 with the _[.underline]#bottom#_ 32-bit element in Rs2.
//
//For the �KMABT32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2.
//
//For the �KMATT32� instruction, it multiplies the _[.underline]#top#_ 32-bit element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2.
//
//The multiplication result is added to the content of 64-bit data in Rd. If the addition result exceeds the Q63 number range (-2^63^ {le} Q63 {le} 2^63^-1), it is saturated to the range and the OV bit is set to 1. The result after saturation is written to Rd. The 32-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//
// res65 = SE65(Rd) + SE65(Rs1.W[0] s* Rs2.W[0]); // KMABB32
// res65 = SE65(Rd) + SE65(Rs1.W[0] s* Rs2.W[1]); // KMABT32
// res65 = SE65(Rd) + SE65(Rs1.W[1] s* Rs2.W[1]); // KMATT32
// if (res65 s> (2^63)-1) {
//   res65 = (2^63)-1;
//   OV = 1;
// } else if (res65 s< -2^63) {
//   res65 = -2^63;
//   OV = 1;
// }
// Rd = res65.D[0];
//
//Instruction syntax:-   KMABB32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMABB32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMABB32 +
//0101101 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMABT32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMABT32 +
//0110101 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMATT32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMATT32 +
//0111101 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KMABB32 {
        encoding: 0b0101101 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMADA32||
//--------------
//Instruction description:-
//
//
//For the �KMADA32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit
//element in Rs1 with the _[.underline]#bottom#_ 32-bit element in Rs2 and then
//adds the result to the result of multiplying the _[.underline]#top#_ 32-bit
//element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2. It is
//actually an alias for the �KMAR64� instruction.
//
//For the �KMAXDA32� instruction, it multiplies the _[.underline]#top#_ 32-bit element in Rs1 with the _[.underline]#bottom#_ 32-bit element in Rs2 and then adds the result to the result of multiplying the _[.underline]#bottom#_ 32-bit element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2.
//
//The result is added to the content of 64-bit data in Rd. If the addition result exceeds the Q63 number range (-2^63^ {le} Q63 {le} 2^63^-1), it is saturated to the range and the OV bit is set to 1. The 64-bit result is written to Rd. The 32-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//
// res66 = SE66(Rd) + SE66(Rs1.W[1] * Rs2.w[1]) + SE66(Rs1.W[0] * Rs2.W[0]); // KMADA32
// res66 = SE66(Rd) + SE66(Rs1.W[1] * Rs2.W[0]) + SE66(Rs1.W[0] * Rs2.W[1]); // KMAXDA32
// if (res66 s> (2^63)-1) {
//   res66 = (2^63)-1;
//   OV = 1;
// } else if (res66 s< -2^63) {
//   res66 = -2^63;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   KMADA32 Rd, Rs1, Rs2    # pseudo mnemonic
//Instruction formate:-
//[.text-center]
//*KMADA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMAR64 +
//1001010 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//* An alias for �KMAR64� instruction
//
//[.text-center]
//*KMAXDA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMAXDA32 +
//0100101 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KMADA32 {
        encoding: 0b1001010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMDA32||
//--------------
//Instruction description:-
//
//
//For the �KMDA32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element of Rs1 with the _[.underline]#bottom#_ 32-bit element of Rs2 and then adds the result to the result of multiplying the _[.underline]#top#_ 32-bit element of Rs1 with the _[.underline]#top#_ 32-bit element of Rs2.
//
//For the �KMXDA32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element of Rs1 with the _[.underline]#top#_ 32-bit element of Rs2 and then adds the result to the result of multiplying the _[.underline]#top#_ 32-bit element of Rs1 with the _[.underline]#bottom#_ 32-bit element of Rs2.
//
//The addition result is checked for saturation. If saturation happens, the result is saturated to 2^63^-1. The final result is written to Rd. The 32-bit contents are treated as signed integers.
//
//Instruction operation:-
//
//
// if ((Rs1 != 0x8000000080000000) or (Rs2 != 0x8000000080000000)) {
//   Rd = (Rs1.W[1] s* Rs2.W[1]) + (Rs1.W[0] s* Rs2.W[0]); // KMDA32
//   Rd = (Rs1.W[1] s* Rs2.W[0]) + (Rs1.W[0] s* Rs2.W[1]); // KMXDA32
// } else {
//   Rd = 0x7fffffffffffffff;
//   OV = 1;
// }
//
//Instruction syntax:-   KMDA32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMDA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMDA32 +
//0011100 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMXDA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMXDA32 +
//0011101 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KMDA32 {
        encoding: 0b0011100 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMADS32||
//--------------
//Instruction description:-
//
//
//For the �KMADS32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element in Rs1 with the _[.underline]#bottom#_ 32-bit element in Rs2 and then subtracts the result from the result of multiplying the _[.underline]#top#_ 32-bit element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2.
//
//For the �KMADRS32� instruction, it multiplies the _[.underline]#top#_ 32-bit element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2 and then subtracts the result from the result of multiplying the _[.underline]#bottom#_ 32-bit element in Rs1 with the _[.underline]#bottom#_ 32-bit element in Rs2.
//
//For the �KMAXDS32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element in Rs1 with the _[.underline]#top#_ 32-bit element in Rs2 and then subtracts the result from the result of multiplying the _[.underline]#top#_ 32-bit element in Rs1 with the _[.underline]#bottom#_ 32-bit element in Rs2.
//
//The subtraction result is then added to the content of 64-bit data in Rd. If the addition result exceeds the Q63 number range (-2^63^ {le} Q63 {le} 2^63^-1), it is saturated to the range and the OV bit is set to 1. The 64-bit result after saturation is written to Rd. The 32-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//
// res66 = SE66(Rd) + SE66(Rs1.W[1] * Rs2.W[1]) - SE66(Rs1.W[0] * Rs2.W[0]); // KMADS32
// res66 = SE66(Rd) + SE66(Rs1.W[0] * Rs2.W[0]) - SE66(Rs1.W[1] * Rs2.W[1]); // KMADRS32
// res66 = SE66(Rd) + SE66(Rs1.W[1] * Rs2.W[0]) - SE66(Rs1.W[0] * Rs2.W[1]); // KMAXDS32
// if (res66 s> (2^63)-1) {
//   res66 = (2^63)-1;
//   OV = 1;
// } else if (res66 s< -2^63) {
//   res66 = -2^63;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   KMADS32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMADS32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMADS32 +
//0101110 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMADRS32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMADRS32 +
//0110110 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMAXDS32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMAXDS32 +
//0111110 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KMADS32 {
        encoding: 0b0101110 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KMSDA32||
//--------------
//Instruction description:-
//
//
//For the �KMSDA32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element of Rs1 with the _[.underline]#bottom#_ 32-bit element of Rs2 and multiplies the _[.underline]#top#_ 32-bit element of Rs1 with the _[.underline]#top#_ 32-bit element of Rs2.
//
//For the �KMSXDA32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element of Rs1 with the _[.underline]#top#_ 32-bit element of Rs2 and multiplies the _[.underline]#top#_ 32-bit element of Rs1 with the _[.underline]#bottom#_ 32-bit element of Rs2.
//
//The two 64-bit multiplication results are then subtracted from the content of Rd. If the subtraction result exceeds the Q63 number range (-2^63^ {le} Q63 {le} 2^63^-1), it is saturated to the range and the OV bit is set to 1. The result after saturation is written to Rd. The 32-bit contents are treated as signed integers.
//
//Instruction operation:-
//
//
// mula64 = Rs1.W[1] s* Rs2.W[1]; mulb64 = Rs1.W[0] s* Rs2.W[0]; // KMSDA32
// mula64 = Rs1.W[1] s* Rs2.W[0]; mulb64 = Rs1.W[0] s* Rs2.W[1]; // KMSXDA32
// res66 = SE66(Rd) - SE66(mula64) - SE66(mulb64);
// if (res66 s> (2^63)-1) {
//   res66 = (2^63)-1;
//   OV = 1;
// } else if (res66 s< -2^63) {
//   res66 = -2^63;
//   OV = 1;
// }
// Rd = res66.D[0];
//
//Instruction syntax:-   KMSDA32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KMSDA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMSDA32 +
//0100110 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KMSXDA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KMSXDA32 +
//0100111 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KMSDA32 {
        encoding: 0b0100110 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLL32||
//--------------
//Instruction description:-
// The 32-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the low-order 5-bits of the value in the Rs2 register. Any shifted value greater than 2^31^-1 is saturated to 2^31^-1. Any shifted value smaller than -2^31^ is saturated to -2^31^. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = Rs2[4:0];
// if (sa != 0) {
//   res[(31+sa):0] = Rs1.W[x] << sa;
//   if (res s> (2^31)-1) {
//     res = 0x7fffffff; OV = 1;
//   } else if (res s< -2^31) {
//     res = 0x80000000; OV = 1;
//   }
//   Rd.W[x] = res.W[0];
// } else {
//   Rd = Rs1;
// }
// for RV64: x=1..0
//
//Instruction syntax:-   KSLL32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLL32 +
//0110010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSLL32 {
        encoding: 0b0110010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLLI32||
//--------------
//Instruction description:-
// The 32-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm5u constant. Any shifted value greater than 2^31^-1 is saturated to 2^31^-1. Any shifted value smaller than -2^31^ is saturated to -2^31^. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.
//
//Instruction operation:-
//
//
// sa = imm5u;
// if (sa != 0) {
//   res[(31+sa):0] = Rs1.W[x] << sa;
//   if (res s> (2^31)-1) {
//     res = 0x7fffffff; OV = 1;
//   } else if (res s< -2^31) {
//     res = 0x80000000; OV = 1;
//   }
//   Rd.W[x] = res.W[0];
// } else {
//   Rd = Rs1;
// }
// for RV64: x=1..0
//
//Instruction syntax:-   KSLLI32 Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLLI32 +
//1000010 |imm5u |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSLLI32 {
        encoding: 0b1000010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSLRA32||
//--------------
//Instruction description:-
// The 32-bit data elements of Rs1 are left-shifted logically or right-shifted arithmetically based on the value of Rs2[5:0]. Rs2[5:0] is in the signed range of [-2^5^, 2^5^-1]. A positive Rs2[5:0] means logical left shift and a negative Rs2[5:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[5:0]. However, the behavior of �Rs2[5:0]==-2^5^ (0x20)� is defined to be equivalent to the behavior of �Rs2[5:0]==-(2^5^-1) (0x21)�.
//
//The left-shifted results are saturated to the 32-bit signed integer range of [-2^31^, 2^31^-1]. For the �.u� form of the instruction, the right-shifted results are added a 1 to the most significant discarded bit position for rounding effect. After the shift, saturation, or rounding, the final results are written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:6] will not affect this instruction.
//
//Instruction operation:-
//
//
// if (Rs2[5:0] s< 0) {
//   sa = -Rs2[5:0];
//   sa = (sa == 32)? 31 : sa;
//   if (�.u� form) {
//     res[31:-1] = SE33(Rs1.W[x][31:sa-1]) + 1;
//     Rd.W[x] = res[31:0];
//   } else {
//     Rd.W[x] = SE32(Rs1.W[x][31:sa]);
//   }
// } else {
//   sa = Rs2[4:0];
//   res[(31+sa):0] = Rs1.W[x] u<< sa;
//   if (res s> (2^31)-1) {
//     res[31:0] = 0x7fffffff; OV = 1;
//   } else if (res s< -2^31) {
//     res[31:0] = 0x80000000; OV = 1;
//   }
//   Rd.W[x] = res.W[0];
// }
// for RV64: x=1..0
//
//Instruction syntax:-   KSLRA32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*KSLRA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRA32 +
//0101011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*KSLRA32.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSLRA32.u +
//0110011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSLRA32 {
        encoding: 0b0101011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSTAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit integer element in [63:32] of Rs1 with the 32-bit integer element in [63:32] of Rs2; at the same time, it subtracts the 32-bit integer element in [31:0] of Rs2 from the 32-bit integer element in [31:0] of Rs1. If any of the results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for addition and [31:0] of Rd for subtraction.
//
//Instruction operation:-
//
//
// res[1] = SE33(Rs1.W[1]) + SE33(Rs2.W[1]);
// res[0] = SE33(Rs1.W[0]) � SE33(Rs2.W[0]);
// if (res[x] s> (2^31)-1) {
//   res[x] = (2^31)-1;
//   OV = 1;
// } else if (res[x] s< -2^31) {
//   res[x] = -2^31;
//   OV = 1;
// }
// Rd.W[1] = res[1].W[0];
// Rd.W[0] = res[0].W[0];
// for RV64, x=1..0
//
//Instruction syntax:-   KSTAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSTAS32 +
//1100000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSTAS32 {
        encoding: 0b1100000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSTSA32||
//--------------
//Instruction description:-
//
//
//This instruction subtracts the 32-bit integer element in [63:32] of Rs2 from the 32-bit integer element in [63:32] of Rs1; at the same time, it adds the 32-bit integer element in [31:0] of Rs1 with the 32-bit integer element in [31:0] of Rs2. If any of the results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for subtraction and [31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res[1] = SE33(Rs1.W[1]) - SE33(Rs2.W[1]);
// res[0] = SE33(Rs1.W[0]) + SE33(Rs2.W[0]);
// if (res[x] s> (2^31)-1) {
//   res[x] = (2^31)-1;
//   OV = 1;
// } else if (res[x] s< -2^31) {
//   res[x] = -2^31;
//   OV = 1;
// }
// Rd.W[1] = res[1].W[0];
// Rd.W[0] = res[0].W[0];
// for RV64, x=1..0
//
//Instruction syntax:-   KSTSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSTSA32 +
//1100001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSTSA32 {
        encoding: 0b1100001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||KSUB32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit signed integer elements in Rs2 from the 32-bit signed integer elements in Rs1. If any of the results exceed the Q31 number range (-2^31^ {le} Q31 {le} 2^31^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = SE33(Rs1.W[x]) - SE33(Rs2.W[x]);
// if (res[x] s> (2^31)-1) {
//   res[x] = (2^31)-1;
//   OV = 1;
// } else if (res[x] s< -2^31) {
//   res[x] = -2^31;
//   OV = 1;
// }
// Rd.W[x] = res[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   KSUB32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|KSUB32 +
//0001001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    KSUB32 {
        encoding: 0b0001001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||PKBB32||
//--------------
//Instruction description:-
//
//
//(PKBB32) moves Rs1.W[0] to Rd.W[1] and moves Rs2.W[0] to Rd.W[0].
//
//(PKBT32) moves Rs1.W[0] to Rd.W[1] and moves Rs2.W[1] to Rd.W[0].
//
//(PKTT32) moves Rs1.W[1] to Rd.W[1] and moves Rs2.W[1] to Rd.W[0].
//
//(PKTB32) moves Rs1.W[1] to Rd.W[1] and moves Rs2.W[0] to Rd.W[0].
//
//Instruction operation:-
//
//
// Rd = CONCAT(Rs1.W[0], Rs2.W[0]); // PKBB32
// Rd = CONCAT(Rs1.W[0], Rs2.W[1]); // PKBT32
// Rd = CONCAT(Rs1.W[1], Rs2.W[1]); // PKTT32
// Rd = CONCAT(Rs1.W[1], Rs2.W[0]); // PKTB32
//
//Instruction syntax:-   PKBB32 Rd, Rs1, Rs2 == PACK Rd, Rs2, Rs1
//Instruction formate:-
//None
    PKBB32 {
                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RADD32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit signed integer elements in Rs1 with the 32-bit signed integer elements in Rs2. The results are first arithmetically right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res33[x] = (SE33(Rs1.W[x]) + SE33(Rs2.W[x])) s>> 1;
// Rd.W[x] = res33[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   RADD32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RADD32 +
//0000000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RADD32 {
        encoding: 0b0000000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RCRAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit signed integer element in [63:32] of Rs1 with the 32-bit signed integer element in [31:0] of Rs2, and subtracts the 32-bit signed integer element in [63:32] of Rs2 from the 32-bit signed integer element in [31:0] of Rs1. The element results are first arithmetically right-shifted by 1 bit and then written to [63:32] of Rd for addition and [31:0] of Rd for subtraction.
//
//Instruction operation:-
//
//
// res_add33 = (SE33(Rs1.W[1]) + SE33(Rs2.W[0])) s>> 1;
// res_sub33 = (SE33(Rs1.W[0]) � SE33(Rs2.W[1])) s>> 1;
// Rd.W[1] = res_add33.W[0];
// Rd.W[0] = res_sub33.W[0];
//
//Instruction syntax:-   RCRAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RCRAS32 +
//0000010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RCRAS32 {
        encoding: 0b0000010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RCRSA32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit signed integer element in [31:0] of Rs2 from the 32-bit signed integer element in [63:32] of Rs1, and adds the 32-bit signed element integer in [31:0] of Rs1 with the 32-bit signed integer element in [63:32] of Rs2. The two results are first arithmetically right-shifted by 1 bit and then written to [63:32] of Rd for subtraction and [31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res_sub33 = (SE33(Rs1.W[1]) - SE33(Rs2.W[0])) s>> 1;
// res_add33 = (SE33(Rs1.W[0]) + SE33(Rs2.W[1])) s>> 1;
// Rd.W[1] = res_sub33.W[0];
// Rd.W[0] = res_add33.W[0];
//
//Instruction syntax:-   RCRSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RCRSA32 +
//0000011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RCRSA32 {
        encoding: 0b0000011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSTAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit signed integer element in [63:32] of Rs1 with the 32-bit signed integer element in [63:32] of Rs2, and subtracts the 32-bit signed integer element in [31:0] of Rs2 from the 32-bit signed integer element in [31:0] of Rs1. The element results are first arithmetically right-shifted by 1 bit and then written to [63:32] of Rd for addition and [31:0] of Rd for subtraction.
//
//Instruction operation:-
//
//
// res_add33 = (SE33(Rs1.W[1]) + SE33(Rs2.W[1])) s>> 1;
// res_sub33 = (SE33(Rs1.W[0]) - SE33(Rs2.W[0])) s>> 1;
// Rd.W[1] = res_add33.W[0];
// Rd.W[0] = res_sub33.W[0];
//
//Instruction syntax:-   RSTAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RCRAS32 +
//1011000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RSTAS32 {
        encoding: 0b1011000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSTSA32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit signed integer element in [63:32] of Rs2 from the 32-bit signed integer element in [63:32] of Rs1, and adds the 32-bit signed element integer in [31:0] of Rs1 with the 32-bit signed integer element in [31:0] of Rs2. The two results are first arithmetically right-shifted by 1 bit and then written to [63:32] of Rd for subtraction and [31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res_sub33 = (SE33(Rs1.W[1]) - SE33(Rs2.W[1])) s>> 1;
// res_add33 = (SE33(Rs1.W[0]) + SE33(Rs2.W[0])) s>> 1;
// Rd.W[1] = res_sub33.W[0];
// Rd.W[0] = res_add33.W[0];
//
//Instruction syntax:-   RSTSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSTSA32 +
//1011001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RSTSA32 {
        encoding: 0b1011001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||RSUB32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit signed integer elements in Rs2 from the 32-bit signed integer elements in Rs1. The results are first arithmetically right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res33[x] = (SE33(Rs1.W[x]) - SE33(Rs2.W[x])) s>> 1;
// Rd.W[x] = res33[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   RSUB32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|RSUB32 +
//0000001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    RSUB32 {
        encoding: 0b0000001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SLL32||
//--------------
//Instruction description:-
// The 32-bit elements in Rs1 are left-shifted logically. And the results are written to Rd. The shifted out bits are filled with zero and the shift amount is specified by the low-order 5-bits of the value in the Rs2 register.
//
//Instruction operation:-
//
//
// sa = Rs2[4:0];
// Rd.W[x] = Rs1.W[x] << sa;
// for RV64: x=1..0
//
//Instruction syntax:-   SLL32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SLL32 +
//0101010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SLL32 {
        encoding: 0b0101010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SLLI32||
//--------------
//Instruction description:-
// The 32-bit elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm5u constant. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm5u;
// Rd.W[x] = Rs1.W[x] << sa;
// for RV64: x=1..0
//
//Instruction syntax:-   SLLI32 Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SLLI32 +
//0111010 |imm5u |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SLLI32 {
        encoding: 0b0111010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMAX32||
//--------------
//Instruction description:-
// This instruction compares the 32-bit signed integer elements in Rs1 with the 32-bit signed integer elements in Rs2 and selects the numbers that is greater than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = (Rs1.W[x] s> Rs2.W[x])? Rs1.W[x] : Rs2.W[x];
// for RV64: x=1..0
//
//Instruction syntax:-   SMAX32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMAX32 +
//1001001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SMAX32 {
        encoding: 0b1001001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMBB32||
//--------------
//Instruction description:-
//
//
//For the �SMBB32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit
//element of Rs1 with the _[.underline]#bottom#_ 32-bit element of Rs2.
//It is actually an alias for �MULSR64� instruction.
//
//For the �SMBT32� instruction, it multiplies the _[.underline]#bottom#_ 32-bit element of Rs1 with the _[.underline]#top#_ 32-bit element of Rs2.
//
//For the �SMTT32� instruction, it multiplies the _[.underline]#top#_ 32-bit element of Rs1 with the _[.underline]#top#_ 32-bit element of Rs2.
//
//The 64-bit multiplication result is written to Rd. The 32-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//....
//res = Rs1.W[0] s* Rs2.W[0]; // SMBB32
//res = Rs1.W[0] s* Rs2.w[1]; // SMBT32
//res = Rs1.W[1] s* Rs2.W[1]; // SMTT32
//Rd = res;
//....
//Instruction syntax:-   SMBB32 Rd, Rs1, Rs2   # pseudo mnemonic
//Instruction formate:-
//[.text-center]
//*SMBB32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MULSR64 +
//1110000 |Rs2 |Rs1 |001 |Rd
//|OP-P +
//1110111
//|===
//
//* An alias for �MULSR64� instruction
//
//[.text-center]
//*SMBT32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMBT32 +
//0001100 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMTT32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMTT32 +
//0010100 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SMBB32 {
        encoding: 0b1110000 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMDS32||
//--------------
//Instruction description:-
//
//
//For the �SMDS32� instruction, it multiplies the bottom 32-bit element of Rs1 with the bottom 32-bit element of Rs2 and then subtracts the result from the result of multiplying the top 32-bit element of Rs1 with the top 32-bit element of Rs2.
//
//For the �SMDRS32� instruction, it multiplies the top 32-bit element of Rs1 with the top 32-bit element of Rs2 and then subtracts the result from the result of multiplying the bottom 32-bit element of Rs1 with the bottom 32-bit element of Rs2.
//
//For the �SMXDS32� instruction, it multiplies the bottom 32-bit element of Rs1 with the top 32-bit element of Rs2 and then subtracts the result from the result of multiplying the top 32-bit element of Rs1 with the bottom 32-bit element of Rs2.
//
//The subtraction result is written to Rd. The 32-bit contents of Rs1 and Rs2 are treated as signed integers.
//
//Instruction operation:-
//
//
// Rd = (Rs1.W[1] s* Rs2.W[1]) - (Rs1.W[0] s* Rs2.W[0]); // SMDS32
// Rd = (Rs1.W[0] s* Rs2.W[0]) - (Rs1.W[1] s* Rs2.W[1]); // SMDRS32
// Rd = (Rs1.W[1] s* Rs2.W[0]) - (Rs1.W[0] s* Rs2.W[1]); // SMXDS32
//
//Instruction syntax:-   SMDS32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SMDS32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMDS32 +
//0101100 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMDRS32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMDRS32 +
//0110100 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SMXDS32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMXDS32 +
//0111100 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SMDS32 {
        encoding: 0b0101100 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SMIN32||
//--------------
//Instruction description:-
// This instruction compares the 32-bit signed integer elements in Rs1 with the 32-bit signed integer elements in Rs2 and selects the numbers that is less than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = (Rs1.W[x] s< Rs2.W[x])? Rs1.W[x] : Rs2.W[x];
// for RV64: x=1..0
//
//Instruction syntax:-   SMIN32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SMIN32 +
//1001000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SMIN32 {
        encoding: 0b1001000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRA32||
//--------------
//Instruction description:-
// The 32-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the data elements. The shift amount is specified by the low-order 5-bits of the value in the Rs2 register. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 32-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = Rs2[4:0];
// if (sa != 0) {
//   if (�.u� form) { // SRA32.u
//     res[31:-1] = SE33(Rs1.W[x][31:sa-1]) + 1;
//     Rd.W[x] = res[31:0];
//   else { // SRA32
//     Rd.W[x] = SE32(Rs1.W[x][31:sa])
//   }
// } else {
//   Rd = Rs1;
// }
// for RV64: x=1..0
//
//Instruction syntax:-   SRA32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SRA32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA32 +
//0101000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRA32.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRA32.u +
//0110000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SRA32 {
        encoding: 0b0101000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRAI32||
//--------------
//Instruction description:-
// The 32-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the 32-bit data elements. The shift amount is specified by the imm5u constant. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 32-bit data to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm5u;
//   if (sa != 0) {
//   if (�.u� form) { // SRAI32.u
//     res[31:-1] = SE33(Rs1.W[x][31:sa-1]) + 1;
//     Rd.W[x] = res[31:0];
//   else { // SRAI32
//     Rd.W[x] = SE32(Rs1.W[x][31:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV64: x=1..0
//
//Instruction syntax:-   SRAI32 Rd, Rs1, imm5u
//Instruction formate:-
//[.text-center]
//*SRAI32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI32 +
//0111000 |imm5u |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRAI32.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAI32u +
//1000000 |imm5u |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SRAI32 {
        encoding: 0b0111000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRAIW||
//--------------
//Instruction description:-
// This instruction right-shifts the lower 32-bit content of Rs1
//arithmetically. The shifted out bits are filled with the sign-bit Rs1[31] and
//the shift amount is specified by the imm5u constant. For the rounding operation,
//a value of 1 is added to the most significant discarded bit of the data to
//calculate the final result. And the result is sign-extended on bit 31 to 64 bits
//and written to Rd.
//
//Instruction operation:-
//
//
// sa = imm5u;
// if (sa�!= 0) {
//   res[31:-1] = SE33(Rs1[31:(sa-1)]) + 1;
//   Rd = SE64(res[31:0]);
// } else {
//   Rd = SE64(Rs1.W[0]);
// }
//
//Instruction syntax:-   SRAIW.u Rd, Rs1, imm5u
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRAIW.u +
//0011010 |imm5u |Rs1 |001 |Rd
//|OP-P +
//1110111
//
    SRAIW {
        encoding: 0b0011010 :: rs2[4:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRL32||
//--------------
//Instruction description:-
// The 32-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the low-order 5-bits of the value in the Rs2 register. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 32-bit data element to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = Rs2[4:0];
// if (sa != 0) {
//   if (�.u� form) { // SRL32.u
//     res[31:-1] = ZE33(Rs1.W[x][31:sa-1]) + 1;
//     Rd.W[x] = res[31:0];
//   else { // SRL32
//     Rd.W[x] = ZE32(Rs1.W[x][31:sa])
//   }
// } else {
//   Rd = Rs1;
// }
// for RV64: x=1..0
//
//Instruction syntax:-   SRL32 Rd, Rs1, Rs2
//Instruction formate:-
//[.text-center]
//*SRL32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRL32 +
//0101001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRL32.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRL32.u +
//0110001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SRL32 {
        encoding: 0b0101001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SRLI32||
//--------------
//Instruction description:-
// The 32-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the imm5u constant. For the rounding operation of the �.u� form, a value of 1 is added to the most significant discarded bit of each 32-bit data to calculate the final results. And the results are written to Rd.
//
//Instruction operation:-
//
//
// sa = imm5u;
// if (sa != 0) {
//   if (�.u� form) { // SRLI32.u
//     res[31:-1] = ZE33(Rs1.W[x][31:sa-1]) + 1;
//     Rd.W[x] = res[31:0];
//   else { // SRLI32
//     Rd.W[x] = ZE32(Rs1.W[x][31:sa]);
//   }
// } else {
//   Rd = Rs1;
// }
// for RV64: x=1..0
//
//Instruction syntax:-   SRLI32 Rd, Rs1, imm5u
//Instruction formate:-
//[.text-center]
//*SRLI32*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRLI32 +
//0111001 |imm5u |Rs1 |010 |Rd
//|OP-P +
//1110111
//|===
//
//[.text-center]
//*SRLI32.u*
//
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SRLI32u +
//1000001 |imm5u |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SRLI32 {
        encoding: 0b0111001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||STAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit integer element in [63:32] of Rs1 with the 32-bit integer element in [63:32] of Rs2, and writes the result to [63:32] of Rd; at the same time, it subtracts the 32-bit integer element in [31:0] of Rs2 from the 32-bit integer element in [31:0] of Rs1, and writes the result to [31:0] of Rd.
//
//Instruction operation:-
//
//
// Rd.W[1] = Rs1.W[1] + Rs2.W[1];
// Rd.W[0] = Rs1.W[0] � Rs2.W[0];
//
//Instruction syntax:-   STAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|STAS32 +
//1111000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    STAS32 {
        encoding: 0b1111000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||STSA32||
//--------------
//Instruction description:-
//
//
//This instruction subtracts the 32-bit integer element in [63:32] of Rs2 from the 32-bit integer element in [63:32] of Rs1, and writes the result to [63:32] of Rd; at the same time, it adds the 32-bit integer element in [31:0] of Rs1 with the 32-bit integer element in [31:0] of Rs2, and writes the result to [31:0] of Rd
//
//Instruction operation:-
//
//
// Rd.W[1] = Rs1.W[1] - Rs2.W[1];
// Rd.W[0] = Rs1.W[0] + Rs2.W[0];
//
//Instruction syntax:-   STSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|STSA32 +
//1111001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    STSA32 {
        encoding: 0b1111001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||SUB32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit integer elements in Rs2 from the 32-bit integer elements in Rs1, and then writes the results to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = Rs1.W[x] - Rs2.W[x];
// for RV64: x=1..0
//
//Instruction syntax:-   SUB32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|SUB32 +
//0100001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    SUB32 {
        encoding: 0b0100001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKADD32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit unsigned integer elements in Rs1 with the 32-bit unsigned integer elements in Rs2. If any of the results exceed the 32-bit unsigned number range (0 {le} RES {le} 2^32^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res33[x] = ZE33(Rs1.W[x]) + ZE33(Rs2.W[x]);
// if (res33[x] u> (2^32)-1) {
//   res33[x] = (2^32)-1;
//   OV = 1;
// }
// Rd.W[x] = res33[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   UKADD32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKADD32 +
//0011000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKADD32 {
        encoding: 0b0011000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKCRAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit unsigned integer element in [63:32] of Rs1 with the 32-bit unsigned integer element in [31:0] of Rs2; at the same time, it subtracts the 32-bit unsigned integer element in [63:32] of Rs2 from the 32-bit unsigned integer element in [31:0] Rs1. If any of the results exceed the 32-bit unsigned number range (0 {le} RES {le} 2^32^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for addition and [31:0] of Rd for subtraction.
//
//Instruction operation:-
//
//
// res1 = ZE33(Rs1.W[1]) + ZE33(Rs2.W[0]);
// res2 = ZE33(Rs1.W[0]) � ZE33(Rs2.W[1]);
// if (res1 u> (2^32)-1) {
//   res1 = (2^32)-1;
//   OV = 1;
// }
// if (res2 s< 0) {
//   res2 = 0;
//   OV = 1;
// }
// Rd.W[1] = res1.W[0];
// Rd.W[0] = res2.W[0];
//
//Instruction syntax:-   UKCRAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKCRAS32 +
//0011010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKCRAS32 {
        encoding: 0b0011010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKCRSA32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit unsigned integer element in [31:0] of Rs2 from the 32-bit unsigned integer element in [63:32] of Rs1; at the same time, it adds the 32-bit unsigned integer element in [63:32] of Rs2 with the 32-bit unsigned integer element in [31:0] Rs1. If any of the results exceed the 32-bit unsigned number range (0 {le} RES {le} 2^32^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for subtraction and [31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res1 = ZE33(Rs1.W[1]) - ZE33(Rs2.W[0]);
// res2 = ZE33(Rs1.W[0]) + ZE33(Rs2.W[1]);
// if (res1 s< 0) {
//   res1 = 0;
//   OV = 1;
// }
// if (res2 u> (2^32)-1) {
//   res2 = (2^32)-1;
//   OV = 1;
// }
// Rd.W[1] = res1.W[0];
// Rd.W[0] = res2.W[0];
//
//Instruction syntax:-   UKCRSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKCRSA32 +
//0011011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKCRSA32 {
        encoding: 0b0011011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSTAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit unsigned integer element in [63:32] of Rs1 with the 32-bit unsigned integer element in [63:32] of Rs2; at the same time, it subtracts the 32-bit unsigned integer element in [31:0] of Rs2 from the 32-bit unsigned integer element in [31:0] Rs1. If any of the results exceed the 32-bit unsigned number range (0 {le} RES {le} 2^32^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for addition and [31:0] of Rd for subtraction.
//
//Instruction operation:-
//
//
// res1 = ZE33(Rs1.W[1]) + ZE33(Rs2.W[1]);
// res2 = ZE33(Rs1.W[0]) � ZE33(Rs2.W[0]);
// if (res1 u> (2^32)-1) {
//   res1 = (2^32)-1;
//   OV = 1;
// }
// if (res2 s< 0) {
//   res2 = 0;
//   OV = 1;
// }
// Rd.W[1] = res1.W[0];
// Rd.W[0] = res2.W[0];
//
//Instruction syntax:-   UKSTAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSTAS32 +
//1110000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKSTAS32 {
        encoding: 0b1110000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSTSA32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit unsigned integer element in [63:32] of Rs2 from the 32-bit unsigned integer element in [63:32] of Rs1; at the same time, it adds the 32-bit unsigned integer element in [31:0] of Rs2 with the 32-bit unsigned integer element in [31:0] Rs1. If any of the results exceed the 32-bit unsigned number range (0 {le} RES {le} 2^32^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to [63:32] of Rd for subtraction and [31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res1 = ZE33(Rs1.W[1]) - ZE33(Rs2.W[1]);
// res2 = ZE33(Rs1.W[0]) + ZE33(Rs2.W[0]);
// if (res1 s< 0) {
//   res1 = 0;
//   OV = 1;
// }
// if (res2 u> (2^32)-1) {
//   res2 = (2^32)-1;
//   OV = 1;
// }
// Rd.W[1] = res1.W[0];
// Rd.W[0] = res2.W[0];
//
//Instruction syntax:-   UKSTSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSTSA32 +
//1110001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKSTSA32 {
        encoding: 0b1110001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UKSUB32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit unsigned integer elements in Rs2 from the 32-bit unsigned integer elements in Rs1. If any of the results exceed the 32-bit unsigned number range (0 {le} RES {le} 2^32^-1), they are saturated to the range and the OV bit is set to 1. The saturated results are written to Rd.
//
//Instruction operation:-
//
//
// res[x] = ZE33(Rs1.W[x]) - ZE33(Rs2.W[x]);
// if (res[x] s< 0) {
//   res[x] = 0;
//   OV = 1;
// }
// Rd.W[x] = res[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   UKSUB32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UKSUB32 +
//0011001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UKSUB32 {
        encoding: 0b0011001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMAX32||
//--------------
//Instruction description:-
// This instruction compares the 32-bit unsigned integer elements in Rs1 with the 32-bit unsigned integer elements in Rs2 and selects the numbers that is greater than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = (Rs1.W[x] u> Rs2.W[x])? Rs1.W[x] : Rs2.W[x];
// for RV64: x=1..0
//
//Instruction syntax:-   UMAX32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMAX32 +
//1010001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UMAX32 {
        encoding: 0b1010001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||UMIN32||
//--------------
//Instruction description:-
// This instruction compares the 32-bit unsigned integer elements in Rs1 with the 32-bit unsigned integer elements in Rs2 and selects the numbers that is less than the other one. The selected results are written to Rd.
//
//Instruction operation:-
//
//
// Rd.W[x] = (Rs1.W[x] <u Rs2.W[x])? Rs1.W[x] : Rs2.W[x];
// for RV64: x=1..0
//
//Instruction syntax:-   UMIN32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|UMIN32 +
//1010000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    UMIN32 {
        encoding: 0b1010000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URADD32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit unsigned integer elements in Rs1
//with the 32-bit unsigned integer elements in Rs2. The 33-bit results are first
//right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res33[x] = (ZE33(Rs1.W[x]) + ZE33(Rs2.W[x])) u>> 1;
// Rd.W[x] = res33[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   URADD32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URADD32 +
//0010000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URADD32 {
        encoding: 0b0010000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URCRAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit unsigned integer element in [63:32]
//of Rs1 with the 32-bit unsigned integer element in [31:0] of Rs2, and subtracts
//the 32-bit unsigned integer element in [63:32] of Rs2 from the 32-bit unsigned
//integer element in [31:0] of Rs1. The 33-bit element results are first
//right-shifted by 1 bit and then written to [63:32] of Rd for addition and [31:0]
//of Rd for subtraction.
//
//Instruction operation:-
//
//
// res_add33 = (ZE33(Rs1.W[1]) + ZE33(Rs2.W[0])) u>> 1;
// res_sub33 = (ZE33(Rs1.W[0]) � ZE33(Rs2.W[1])) u>> 1;
// Rd.W[1] = res_add33.W[0];
// Rd.W[0] = res_sub33.W[0];
//
//Instruction syntax:-   URCRAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URCRAS32 +
//0010010 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URCRAS32 {
        encoding: 0b0010010 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URCRSA32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit unsigned integer element in
//[31:0] of Rs2 from the 32-bit unsigned integer element in [63:32] of Rs1, and
//adds the 32-bit unsigned element integer in [31:0] of Rs1 with the 32-bit
//unsigned integer element in [63:32] of Rs2. The two 33-bit results are first
//right-shifted by 1 bit and then written to [63:32] of Rd for subtraction and
//[31:0] of Rd for addition.
//
//Instruction operation:-
//
//
// res_sub33 = (ZE33(Rs1.W[1]) - ZE33(Rs2.W[0])) u>> 1;
// res_add33 = (ZE33(Rs1.W[0]) + ZE33(Rs2.W[1])) u>> 1;
// Rd.W[1] = res_sub33.W[0];
// Rd.W[0] = res_add33.W[0];
//
//Instruction syntax:-   URCRSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URCRSA32 +
//0010011 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URCRSA32 {
        encoding: 0b0010011 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSTAS32||
//--------------
//Instruction description:-
// This instruction adds the 32-bit unsigned integer element in [63:32]
//of Rs1 with the 32-bit unsigned integer element in [63:32] of Rs2, and subtracts
//the 32-bit unsigned integer element in [31:0] of Rs2 from the 32-bit unsigned
//integer element in [31:0] of Rs1. The 33-bit element results are first
//right-shifted by 1 bit and then written to [63:32] of Rd for addition and [31:0]
//of Rd for subtraction.
//
//Instruction operation:-
//
//
// res_add33 = (ZE33(Rs1.W[1]) + ZE33(Rs2.W[1])) u>> 1;
// res_sub33 = (ZE33(Rs1.W[0]) � ZE33(Rs2.W[0])) u>> 1;
// Rd.W[1] = res_add33.W[0];
// Rd.W[0] = res_sub33.W[0];
//
//Instruction syntax:-   URSTAS32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSTAS32 +
//1101000 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URSTAS32 {
        encoding: 0b1101000 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSTSA32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit unsigned integer element in
//[63:32] of Rs2 from the 32-bit unsigned integer element in [63:32] of Rs1, and
//adds the 32-bit unsigned element integer in [31:0] of Rs1 with the 32-bit unsigned
//integer element in [31:0] of Rs2. The two 33-bit results are first right-shifted
//by 1 bit and then written to [63:32] of Rd for subtraction and [31:0] of Rd for
//addition.
//
//Instruction operation:-
//
//
// res_sub33 = (ZE33(Rs1.W[1]) - ZE33(Rs2.W[1])) u>> 1;
// res_add33 = (ZE33(Rs1.W[0]) + ZE33(Rs2.W[0])) u>> 1;
// Rd.W[1] = res_sub33.W[0];
// Rd.W[0] = res_add33.W[0];
//
//Instruction syntax:-   URSTSA32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSTSA32 +
//1101001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URSTSA32 {
        encoding: 0b1101001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||URSUB32||
//--------------
//Instruction description:-
// This instruction subtracts the 32-bit unsigned integer elements
//in Rs2 from the 32-bit unsigned integer elements in Rs1. The 33-bit results are
//first right-shifted by 1 bit and then written to Rd.
//
//Instruction operation:-
//
//
// res33[x] = (ZE33(Rs1.W[x]) - ZE33(Rs2.W[x])) u>> 1;
// Rd.W[x] = res33[x].W[0];
// for RV64: x=1..0
//
//Instruction syntax:-   URSUB32 Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|URSUB32 +
//0010001 |Rs2 |Rs1 |010 |Rd
//|OP-P +
//1110111
//
    URSUB32 {
        encoding: 0b0010001 :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||BPICK||
//--------------
//Instruction description:-
// This instruction selects individual bits from Rs1 or Rs2, based on
//the bit mask value in Rc. If a bit in Rc is 1, the corresponding bit is from Rs1;
//otherwise, the corresponding bit is from Rs2. The selection results are written to Rd.
//
//Instruction operation:-
//
//
// Rd[x] = Rc[x]? Rs1[x] : Rs2[x];
// for RV32, x=31..0
// for RV64, x=63..0
//
//Instruction syntax:-   BPICK Rd, Rs1, Rs2, Rc
//Instruction formate:-
//[cols="7*^.^"]
//|===
//l|31    27 l|26    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|Rc |BPICK +
//00 |Rs2 |Rs1 |011 |Rd
//|OP-P +
//1110111
//
    BPICK {
        encoding: 0b00:: rs3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs3)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



//--------------
// ||MAXW||
//--------------
//Instruction description:-
// This instruction compares two signed 32-bit integers stored in Rs1 and Rs2, picks the larger value as the result, and writes the result to Rd.
//
//Instruction operation:-
//
//
// if (Rs1.W[0] s>= Rs2.W[0]) {
//   res = Rs1.W[0];
// } else {
//   res = Rs2.W[0];
// }
// Rd = res;       // RV32
// Rd = SE64(res); // RV64 
//
//Instruction syntax:-   MAXW Rd, Rs1, Rs2
//Instruction formate:-
//[cols="6*^.^"]
//|===
//l|31    25 l|24    20 l|19    15 l|14    12 l|11    7 l|6    0
//|MAXW +
//1111001 |Rs2 |Rs1 |000 |Rd
//|OP-P +
//1110111
//
    MAXW {
        encoding: 0b1111001 :: rs2[4:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b1110111;
        args_disass:"{name(rd)}, {name(rs2)}, {name(rs1)}";
        behavior: {
            if(rd != 0) {


                X[rd] = rd_val;
            }
        }
    }
    }



